import {
  ActionKind,
  AddPublisherAction,
  AddSubscriberAction,
  DEFAULT_TAR_NAME,
  DEFAULT_WEB_SOCKET_PORT,
  ExitPublisherAction,
  ExitSubscriberAction,
  HOST_API_TYPES_FILE_NAME,
  MF_SERVER_IDENTIFIER,
  Message,
  NotifyWebClientAction,
  REMOTE_ALIAS_IDENTIFIER,
  REMOTE_API_TYPES_FILE_NAME,
  UpdateKind,
  UpdateMode,
  UpdatePublisherAction,
  WEB_SOCKET_CONNECT_MAGIC_ID,
  __async,
  __export,
  __name,
  __publicField,
  __require,
  __spreadProps,
  __spreadValues
} from "./chunk-MQRIERJP.js";

// packages/dts-plugin/src/core/configurations/remotePlugin.ts
import { existsSync as existsSync2 } from "fs";
import { dirname as dirname2, join as join3, resolve as resolve3, extname as extname2 } from "path";
import { utils as utils2 } from "@module-federation/managers";
import typescript from "typescript";

// packages/dts-plugin/src/core/lib/utils.ts
import fs3 from "fs";
import path3 from "path";
import axios from "axios";
import http from "http";
import https from "https";
import ansiColors2 from "ansi-colors";

// packages/dts-plugin/src/core/lib/DTSManager.ts
import ansiColors from "ansi-colors";
import path2 from "path";
import { rm as rm3 } from "fs/promises";
import fs2 from "fs";
import { MANIFEST_EXT, inferAutoPublicPath } from "@module-federation/sdk";
import cloneDeepWith from "lodash.clonedeepwith";
import { ThirdPartyExtractor as ThirdPartyExtractor2 } from "@module-federation/third-party-dts-extractor";

// packages/dts-plugin/src/core/lib/archiveHandler.ts
import AdmZip from "adm-zip";
import { resolve as resolve2, join as join2 } from "path";
import { rm as rm2 } from "fs/promises";

// packages/dts-plugin/src/core/lib/typeScriptCompiler.ts
import { ensureDirSync, writeFileSync, existsSync } from "fs-extra";
import { stat, readdir, writeFile, rm, readFile } from "fs/promises";
import { randomUUID } from "crypto";
import { dirname, join, normalize, relative, resolve, sep, extname, isAbsolute } from "path";
import { ThirdPartyExtractor } from "@module-federation/third-party-dts-extractor";
import { exec } from "child_process";
import util from "util";
import { TEMP_DIR } from "@module-federation/sdk";
var STARTS_WITH_SLASH = /^\//;
var DEFINITION_FILE_EXTENSION = ".d.ts";
var retrieveMfTypesPath = /* @__PURE__ */ __name((tsConfig, remoteOptions) => normalize(tsConfig.compilerOptions.outDir.replace(remoteOptions.compiledTypesFolder, "")), "retrieveMfTypesPath");
var retrieveOriginalOutDir = /* @__PURE__ */ __name((tsConfig, remoteOptions) => normalize(tsConfig.compilerOptions.outDir.replace(remoteOptions.compiledTypesFolder, "").replace(remoteOptions.typesFolder, "")), "retrieveOriginalOutDir");
var retrieveMfAPITypesPath = /* @__PURE__ */ __name((tsConfig, remoteOptions) => join(retrieveOriginalOutDir(tsConfig, remoteOptions), `${remoteOptions.typesFolder}.d.ts`), "retrieveMfAPITypesPath");
function writeTempTsConfig(tsConfig, context) {
  const tempTsConfigJsonPath = resolve(context, "node_modules", TEMP_DIR, `tsconfig.${randomUUID()}.json`);
  ensureDirSync(dirname(tempTsConfigJsonPath));
  writeFileSync(tempTsConfigJsonPath, JSON.stringify(tsConfig, null, 2));
  return tempTsConfigJsonPath;
}
__name(writeTempTsConfig, "writeTempTsConfig");
var removeExt = /* @__PURE__ */ __name((f) => {
  const ext = extname(f);
  const regexPattern = new RegExp(`\\${ext}$`);
  return f.replace(regexPattern, "");
}, "removeExt");
function getExposeKey(options) {
  const { filePath, rootDir, outDir, mapExposeToEntry } = options;
  const relativeFilePath = removeExt(relative(outDir, filePath.replace(new RegExp(`\\.d.ts$`), "")));
  return mapExposeToEntry[relativeFilePath];
}
__name(getExposeKey, "getExposeKey");
var processTypesFile = /* @__PURE__ */ __name((options) => __async(void 0, null, function* () {
  const { outDir, filePath, rootDir, cb, mapExposeToEntry, mfTypePath } = options;
  if (!existsSync(filePath)) {
    return;
  }
  const stats = yield stat(filePath);
  if (stats.isDirectory()) {
    const files = yield readdir(filePath);
    yield Promise.all(files.map((file) => processTypesFile(__spreadProps(__spreadValues({}, options), {
      filePath: join(filePath, file)
    }))));
  } else if (filePath.endsWith(".d.ts")) {
    const exposeKey = getExposeKey({
      filePath,
      rootDir,
      outDir,
      mapExposeToEntry
    });
    if (exposeKey) {
      const sourceEntry = exposeKey === "." ? "index" : exposeKey;
      const mfeTypeEntry = join(mfTypePath, `${sourceEntry}${DEFINITION_FILE_EXTENSION}`);
      const mfeTypeEntryDirectory = dirname(mfeTypeEntry);
      const relativePathToOutput = relative(mfeTypeEntryDirectory, filePath).replace(DEFINITION_FILE_EXTENSION, "").replace(STARTS_WITH_SLASH, "").split(sep).join("/");
      ensureDirSync(mfeTypeEntryDirectory);
      yield writeFile(mfeTypeEntry, `export * from './${relativePathToOutput}';
export { default } from './${relativePathToOutput}';`);
    }
    const content = yield readFile(filePath, "utf8");
    cb(content);
  }
}), "processTypesFile");
var compileTs = /* @__PURE__ */ __name((mapComponentsToExpose, tsConfig, remoteOptions) => __async(void 0, null, function* () {
  if (!Object.keys(mapComponentsToExpose).length) {
    return;
  }
  const { compilerOptions } = tsConfig;
  const tempTsConfigJsonPath = writeTempTsConfig(tsConfig, remoteOptions.context);
  try {
    const mfTypePath = retrieveMfTypesPath(tsConfig, remoteOptions);
    const thirdPartyExtractor = new ThirdPartyExtractor(resolve(mfTypePath, "node_modules"), remoteOptions.context);
    const execPromise = util.promisify(exec);
    const cmd = `npx ${remoteOptions.compilerInstance} --project ${tempTsConfigJsonPath}`;
    try {
      yield execPromise(cmd);
    } catch (err) {
      throw new Error(`compile TS failed, the original command is '${cmd}'`);
    }
    const mapExposeToEntry = Object.fromEntries(Object.entries(mapComponentsToExpose).map(([exposed, filename]) => {
      const normalizedFileName = normalize(filename);
      let relativeFileName = "";
      if (isAbsolute(normalizedFileName)) {
        relativeFileName = relative(tsConfig.compilerOptions.rootDir, normalizedFileName);
      } else {
        relativeFileName = relative(tsConfig.compilerOptions.rootDir, resolve(remoteOptions.context, normalizedFileName));
      }
      return [
        removeExt(relativeFileName),
        exposed
      ];
    }));
    const cb = remoteOptions.extractThirdParty ? thirdPartyExtractor.collectPkgs.bind(thirdPartyExtractor) : () => void 0;
    yield processTypesFile({
      outDir: compilerOptions.outDir,
      filePath: compilerOptions.outDir,
      rootDir: compilerOptions.rootDir,
      mfTypePath,
      cb,
      mapExposeToEntry
    });
    if (remoteOptions.extractThirdParty) {
      yield thirdPartyExtractor.copyDts();
    }
    yield rm(tempTsConfigJsonPath);
  } catch (err) {
    if (isDebugMode()) {
      console.log("tsconfig: ", JSON.stringify(tsConfig, null, 2));
    }
    throw err;
  }
}), "compileTs");

// packages/dts-plugin/src/server/message/API/API.ts
var APIKind;
(function(APIKind2) {
  APIKind2["UPDATE_SUBSCRIBER"] = "UPDATE_SUBSCRIBER";
  APIKind2["RELOAD_WEB_CLIENT"] = "RELOAD_WEB_CLIENT";
  APIKind2["FETCH_TYPES"] = "FETCH_TYPES";
})(APIKind || (APIKind = {}));
var _API = class _API extends Message {
  constructor(content, kind) {
    super("API", kind);
    __publicField(this, "code");
    __publicField(this, "payload");
    const { code, payload } = content;
    this.code = code;
    this.payload = payload;
  }
};
__name(_API, "API");
var API = _API;

// packages/dts-plugin/src/server/message/API/UpdateSubscriber.ts
var _UpdateSubscriberAPI = class _UpdateSubscriberAPI extends API {
  constructor(payload) {
    super({
      code: 0,
      payload
    }, APIKind.UPDATE_SUBSCRIBER);
  }
};
__name(_UpdateSubscriberAPI, "UpdateSubscriberAPI");
var UpdateSubscriberAPI = _UpdateSubscriberAPI;

// packages/dts-plugin/src/server/message/API/ReloadWebClient.ts
var _ReloadWebClientAPI = class _ReloadWebClientAPI extends API {
  constructor(payload) {
    super({
      code: 0,
      payload
    }, APIKind.RELOAD_WEB_CLIENT);
  }
};
__name(_ReloadWebClientAPI, "ReloadWebClientAPI");
var ReloadWebClientAPI = _ReloadWebClientAPI;

// packages/dts-plugin/src/server/message/API/FetchTypes.ts
var _FetchTypesAPI = class _FetchTypesAPI extends API {
  constructor(payload) {
    super({
      code: 0,
      payload
    }, APIKind.FETCH_TYPES);
  }
};
__name(_FetchTypesAPI, "FetchTypesAPI");
var FetchTypesAPI = _FetchTypesAPI;

// packages/dts-plugin/src/server/utils/index.ts
import net from "net";
import { SEPARATOR } from "@module-federation/sdk";

// packages/dts-plugin/src/server/utils/logTransform.ts
import chalk from "chalk";

// packages/dts-plugin/src/server/message/Log/Log.ts
var LogLevel;
(function(LogLevel2) {
  LogLevel2["LOG"] = "LOG";
  LogLevel2["WARN"] = "WARN";
  LogLevel2["ERROR"] = "ERROR";
})(LogLevel || (LogLevel = {}));
var LogKind;
(function(LogKind2) {
  LogKind2["BrokerExitLog"] = "BrokerExitLog";
  LogKind2["PublisherRegisteredLog"] = "PublisherRegisteredLog";
})(LogKind || (LogKind = {}));
var _Log = class _Log extends Message {
  constructor(level, kind, ignoreVerbose = false) {
    super("Log", kind);
    __publicField(this, "level");
    __publicField(this, "ignoreVerbose", false);
    this.level = level;
    this.ignoreVerbose = ignoreVerbose;
  }
};
__name(_Log, "Log");
var Log = _Log;

// packages/dts-plugin/src/server/message/Log/BrokerExitLog.ts
var _BrokerExitLog = class _BrokerExitLog extends Log {
  constructor() {
    super(LogLevel.LOG, LogKind.BrokerExitLog);
  }
};
__name(_BrokerExitLog, "BrokerExitLog");
var BrokerExitLog = _BrokerExitLog;

// packages/dts-plugin/src/server/utils/log.ts
import { logger } from "@module-federation/sdk";
import * as log4js from "log4js";
import chalk2 from "chalk";
function fileLog(msg, module, level) {
  var _a3, _b;
  if (!((_a3 = process == null ? void 0 : process.env) == null ? void 0 : _a3["FEDERATION_DEBUG"])) {
    return;
  }
  log4js.configure({
    appenders: {
      [module]: {
        type: "file",
        filename: ".mf/typesGenerate.log"
      },
      default: {
        type: "file",
        filename: ".mf/typesGenerate.log"
      }
    },
    categories: {
      [module]: {
        appenders: [
          module
        ],
        level: "error"
      },
      default: {
        appenders: [
          "default"
        ],
        level: "trace"
      }
    }
  });
  const logger4 = log4js.getLogger(module);
  logger4.level = "debug";
  (_b = logger4[level]) == null ? void 0 : _b.call(logger4, msg);
}
__name(fileLog, "fileLog");
function error(error2, action, from) {
  const err = error2 instanceof Error ? error2 : new Error(`${action} error`);
  fileLog(`[${action}] error: ${err}`, from, "fatal");
  return err.toString();
}
__name(error, "error");

// packages/dts-plugin/src/server/utils/getIPV4.ts
import os from "os";
var localIpv4 = "127.0.0.1";
var getIpv4Interfaces = /* @__PURE__ */ __name(() => {
  try {
    const interfaces = os.networkInterfaces();
    const ipv4Interfaces = [];
    Object.values(interfaces).forEach((detail) => {
      detail == null ? void 0 : detail.forEach((detail2) => {
        const familyV4Value = typeof detail2.family === "string" ? "IPv4" : 4;
        if (detail2.family === familyV4Value && detail2.address !== localIpv4) {
          ipv4Interfaces.push(detail2);
        }
      });
    });
    return ipv4Interfaces;
  } catch (_err) {
    return [];
  }
}, "getIpv4Interfaces");
var getIPV4 = /* @__PURE__ */ __name(() => {
  const ipv4Interfaces = getIpv4Interfaces();
  const ipv4Interface = ipv4Interfaces[0] || {
    address: localIpv4
  };
  return ipv4Interface.address;
}, "getIPV4");

// packages/dts-plugin/src/server/utils/index.ts
function getIdentifier(options) {
  const { ip, name } = options;
  return `mf ${SEPARATOR}${name}${ip ? `${SEPARATOR}${ip}` : ""}`;
}
__name(getIdentifier, "getIdentifier");
function fib(n) {
  let i = 2;
  const res = [
    0,
    1,
    1
  ];
  while (i <= n) {
    res[i] = res[i - 1] + res[i - 2];
    i++;
  }
  return res[n];
}
__name(fib, "fib");
function getFreePort() {
  return new Promise((resolve4, reject) => {
    const server = net.createServer();
    server.unref();
    server.on("error", reject);
    server.listen(0, () => {
      const { port } = server.address();
      server.close(() => {
        resolve4(port);
      });
    });
  });
}
__name(getFreePort, "getFreePort");

// packages/dts-plugin/src/server/Publisher.ts
var _Publisher = class _Publisher {
  constructor(ctx) {
    __publicField(this, "_ip");
    __publicField(this, "_name");
    __publicField(this, "_remoteTypeTarPath");
    __publicField(this, "_subscribers");
    __publicField(this, "_ws");
    __publicField(this, "dynamicRemoteMap");
    this._name = ctx.name;
    this._ip = ctx.ip;
    this._remoteTypeTarPath = ctx.remoteTypeTarPath;
    this._subscribers = /* @__PURE__ */ new Map();
    this._ws = ctx.ws;
    this.dynamicRemoteMap = /* @__PURE__ */ new Map();
  }
  get identifier() {
    return getIdentifier({
      name: this._name,
      ip: this._ip
    });
  }
  get name() {
    return this._name;
  }
  get ip() {
    return this._ip;
  }
  get remoteTypeTarPath() {
    return this._remoteTypeTarPath;
  }
  get hasSubscribes() {
    return Boolean(this._subscribers.size);
  }
  get subscribers() {
    return this._subscribers;
  }
  addSubscriber(identifier, subscriber) {
    fileLog(`${this.name} set subscriber: ${identifier}`, "Publisher", "info");
    this._subscribers.set(identifier, subscriber);
  }
  removeSubscriber(identifier) {
    if (this._subscribers.has(identifier)) {
      fileLog(`${this.name} removeSubscriber: ${identifier}`, "Publisher", "warn");
      this._subscribers.delete(identifier);
    }
  }
  notifySubscriber(subscriberIdentifier, options) {
    const subscriber = this._subscribers.get(subscriberIdentifier);
    if (!subscriber) {
      fileLog(`[notifySubscriber] ${this.name} notifySubscriber: ${subscriberIdentifier}, does not exits`, "Publisher", "error");
      return;
    }
    const api = new UpdateSubscriberAPI(options);
    subscriber.send(JSON.stringify(api));
    fileLog(`[notifySubscriber] ${this.name} notifySubscriber: ${JSON.stringify(subscriberIdentifier)}, message: ${JSON.stringify(api)}`, "Publisher", "info");
  }
  fetchRemoteTypes(options) {
    fileLog(`[fetchRemoteTypes] ${this.name} fetchRemoteTypes, options: ${JSON.stringify(options)}, ws: ${Boolean(this._ws)}`, "Publisher", "info");
    if (!this._ws) {
      return;
    }
    const api = new FetchTypesAPI(options);
    this._ws.send(JSON.stringify(api));
  }
  notifySubscribers(options) {
    const api = new UpdateSubscriberAPI(options);
    this.broadcast(api);
  }
  broadcast(message) {
    if (this.hasSubscribes) {
      this._subscribers.forEach((subscriber, key) => {
        fileLog(`[BroadCast] ${this.name} notifySubscriber: ${key}, PID: ${process.pid}, message: ${JSON.stringify(message)}`, "Publisher", "info");
        subscriber.send(JSON.stringify(message));
      });
    } else {
      fileLog(`[BroadCast] ${this.name}'s subscribe is empty`, "Publisher", "warn");
    }
  }
  close() {
    this._ws = void 0;
    this._subscribers.forEach((_subscriber, identifier) => {
      fileLog(`[BroadCast] close ${this.name} remove: ${identifier}`, "Publisher", "warn");
      this.removeSubscriber(identifier);
    });
  }
};
__name(_Publisher, "Publisher");
var Publisher = _Publisher;

// packages/dts-plugin/src/server/DevServer.ts
import WebSocket2 from "isomorphic-ws";

// packages/dts-plugin/src/server/broker/Broker.ts
import { createServer } from "http";
import WebSocket from "isomorphic-ws";
import schedule from "node-schedule";
import { parse } from "url";
var _Broker = class _Broker {
  constructor() {
    __publicField(this, "_publisherMap", /* @__PURE__ */ new Map());
    __publicField(this, "_webClientMap", /* @__PURE__ */ new Map());
    __publicField(this, "_webSocketServer");
    __publicField(this, "_secureWebSocketServer");
    __publicField(this, "_tmpSubscriberShelter", /* @__PURE__ */ new Map());
    __publicField(this, "_scheduleJob", null);
    this._setSchedule();
    this._startWsServer();
    this._stopWhenSIGTERMOrSIGINT();
    this._handleUnexpectedExit();
  }
  get hasPublishers() {
    return Boolean(this._publisherMap.size);
  }
  _startWsServer() {
    return __async(this, null, function* () {
      const wsHandler = /* @__PURE__ */ __name((ws, req) => {
        const { url: reqUrl = "" } = req;
        const { query } = parse(reqUrl, true);
        const { WEB_SOCKET_CONNECT_MAGIC_ID: WEB_SOCKET_CONNECT_MAGIC_ID2 } = query;
        if (WEB_SOCKET_CONNECT_MAGIC_ID2 === _Broker.WEB_SOCKET_CONNECT_MAGIC_ID) {
          ws.on("message", (message) => {
            try {
              const text = message.toString();
              const action = JSON.parse(text);
              fileLog(`${action == null ? void 0 : action.kind} action received `, "Broker", "info");
              this._takeAction(action, ws);
            } catch (error2) {
              fileLog(`parse action message error: ${error2}`, "Broker", "error");
            }
          });
          ws.on("error", (e) => {
            fileLog(`parse action message error: ${e}`, "Broker", "error");
          });
        } else {
          ws.send("Invalid CONNECT ID.");
          fileLog("Invalid CONNECT ID.", "Broker", "warn");
          ws.close();
        }
      }, "wsHandler");
      const server = createServer();
      this._webSocketServer = new WebSocket.Server({
        noServer: true
      });
      this._webSocketServer.on("error", (err) => {
        fileLog(`ws error: 
${err.message}
 ${err.stack}`, "Broker", "error");
      });
      this._webSocketServer.on("listening", () => {
        fileLog(`WebSocket server is listening on port ${_Broker.DEFAULT_WEB_SOCKET_PORT}`, "Broker", "info");
      });
      this._webSocketServer.on("connection", wsHandler);
      this._webSocketServer.on("close", (code) => {
        fileLog(`WebSocket Server Close with Code ${code}`, "Broker", "warn");
        this._webSocketServer && this._webSocketServer.close();
        this._webSocketServer = void 0;
      });
      server.on("upgrade", (req, socket, head) => {
        var _a3;
        if (req.url) {
          const { pathname } = parse(req.url);
          if (pathname === "/") {
            (_a3 = this._webSocketServer) == null ? void 0 : _a3.handleUpgrade(req, socket, head, (ws) => {
              var _a4;
              (_a4 = this._webSocketServer) == null ? void 0 : _a4.emit("connection", ws, req);
            });
          }
        }
      });
      server.listen(_Broker.DEFAULT_WEB_SOCKET_PORT);
    });
  }
  _takeAction(action, client) {
    return __async(this, null, function* () {
      const { kind, payload } = action;
      if (kind === ActionKind.ADD_PUBLISHER) {
        yield this._addPublisher(payload, client);
      }
      if (kind === ActionKind.UPDATE_PUBLISHER) {
        yield this._updatePublisher(payload, client);
      }
      if (kind === ActionKind.ADD_SUBSCRIBER) {
        yield this._addSubscriber(payload, client);
      }
      if (kind === ActionKind.EXIT_SUBSCRIBER) {
        yield this._removeSubscriber(payload, client);
      }
      if (kind === ActionKind.EXIT_PUBLISHER) {
        yield this._removePublisher(payload, client);
      }
      if (kind === ActionKind.ADD_WEB_CLIENT) {
        yield this._addWebClient(payload, client);
      }
      if (kind === ActionKind.NOTIFY_WEB_CLIENT) {
        yield this._notifyWebClient(payload, client);
      }
      if (kind === ActionKind.FETCH_TYPES) {
        yield this._fetchTypes(payload, client);
      }
      if (kind === ActionKind.ADD_DYNAMIC_REMOTE) {
        this._addDynamicRemote(payload);
      }
    });
  }
  _addPublisher(context, client) {
    return __async(this, null, function* () {
      const { name, ip, remoteTypeTarPath } = context != null ? context : {};
      const identifier = getIdentifier({
        name,
        ip
      });
      if (this._publisherMap.has(identifier)) {
        fileLog(`[${ActionKind.ADD_PUBLISHER}] ${identifier} has been added, this action will be ignored`, "Broker", "warn");
        return;
      }
      try {
        const publisher = new Publisher({
          name,
          ip,
          remoteTypeTarPath,
          ws: client
        });
        this._publisherMap.set(identifier, publisher);
        fileLog(`[${ActionKind.ADD_PUBLISHER}] ${identifier} Adding Publisher Succeed`, "Broker", "info");
        const tmpSubScribers = this._getTmpSubScribers(identifier);
        if (tmpSubScribers) {
          fileLog(`[${ActionKind.ADD_PUBLISHER}] consumeTmpSubscriber set ${publisher.name}\u2019s subscribers `, "Broker", "info");
          this._consumeTmpSubScribers(publisher, tmpSubScribers);
          this._clearTmpSubScriberRelation(identifier);
        }
      } catch (err) {
        const msg = error(err, ActionKind.ADD_PUBLISHER, "Broker");
        client.send(msg);
        client.close();
      }
    });
  }
  _updatePublisher(context, client) {
    return __async(this, null, function* () {
      const { name, updateMode, updateKind, updateSourcePaths, remoteTypeTarPath, ip } = context != null ? context : {};
      const identifier = getIdentifier({
        name,
        ip
      });
      if (!this._publisherMap.has(identifier)) {
        fileLog(`[${ActionKind.UPDATE_PUBLISHER}] ${identifier} has not been started, this action will be ignored
        this._publisherMap: ${JSON.stringify(this._publisherMap.entries())}
        `, "Broker", "warn");
        return;
      }
      try {
        const publisher = this._publisherMap.get(identifier);
        fileLog(
          // eslint-disable-next-line max-len
          `[${ActionKind.UPDATE_PUBLISHER}] ${identifier} update, and notify subscribers to update`,
          "Broker",
          "info"
        );
        if (publisher) {
          publisher.notifySubscribers({
            remoteTypeTarPath,
            name,
            updateMode,
            updateKind,
            updateSourcePaths: updateSourcePaths || []
          });
          this._publisherMap.forEach((p) => {
            if (p.name === publisher.name) {
              return;
            }
            const dynamicRemoteInfo = p.dynamicRemoteMap.get(identifier);
            if (dynamicRemoteInfo) {
              fileLog(
                // eslint-disable-next-line max-len
                `dynamicRemoteInfo: ${JSON.stringify(dynamicRemoteInfo)}, identifier:${identifier} publish: ${p.name}`,
                "Broker",
                "info"
              );
              p.fetchRemoteTypes({
                remoteInfo: dynamicRemoteInfo,
                once: false
              });
            }
          });
        }
      } catch (err) {
        const msg = error(err, ActionKind.UPDATE_PUBLISHER, "Broker");
        client.send(msg);
        client.close();
      }
    });
  }
  _fetchTypes(context, _client) {
    return __async(this, null, function* () {
      const { name, ip, remoteInfo } = context != null ? context : {};
      const identifier = getIdentifier({
        name,
        ip
      });
      try {
        const publisher = this._publisherMap.get(identifier);
        fileLog(`[${ActionKind.FETCH_TYPES}] ${identifier} fetch types`, "Broker", "info");
        if (publisher) {
          publisher.fetchRemoteTypes({
            remoteInfo,
            once: true
          });
        }
      } catch (err) {
        fileLog(`[${ActionKind.FETCH_TYPES}] ${identifier} fetch types fail , error info: ${err}`, "Broker", "error");
      }
    });
  }
  _addDynamicRemote(context) {
    const { name, ip, remoteInfo, remoteIp } = context != null ? context : {};
    const identifier = getIdentifier({
      name,
      ip
    });
    const publisher = this._publisherMap.get(identifier);
    const remoteId = getIdentifier({
      name: remoteInfo.name,
      ip: remoteIp
    });
    fileLog(`[${ActionKind.ADD_DYNAMIC_REMOTE}] identifier:${identifier},publisher: ${publisher.name}, remoteId:${remoteId}`, "Broker", "error");
    if (!publisher || publisher.dynamicRemoteMap.has(remoteId)) {
      return;
    }
    publisher.dynamicRemoteMap.set(remoteId, remoteInfo);
  }
  //  app1 consumes provider1,provider2. Dependencies at this time: publishers: [provider1, provider2], subscriberName: app1
  // provider1 is app1's remote
  _addSubscriber(context, client) {
    return __async(this, null, function* () {
      const { publishers, name: subscriberName } = context != null ? context : {};
      publishers.forEach((publisher) => {
        const { name, ip } = publisher;
        const identifier = getIdentifier({
          name,
          ip
        });
        if (!this._publisherMap.has(identifier)) {
          fileLog(`[${ActionKind.ADD_SUBSCRIBER}]: ${identifier} has not been started, ${subscriberName} will add the relation to tmp shelter`, "Broker", "warn");
          this._addTmpSubScriberRelation({
            name: getIdentifier({
              name: context.name,
              ip: context.ip
            }),
            client
          }, publisher);
          return;
        }
        try {
          const registeredPublisher = this._publisherMap.get(identifier);
          if (registeredPublisher) {
            registeredPublisher.addSubscriber(getIdentifier({
              name: subscriberName,
              ip: context.ip
            }), client);
            fileLog(
              // eslint-disable-next-line @ies/eden/max-calls-in-template
              `[${ActionKind.ADD_SUBSCRIBER}]: ${identifier} has been started, Adding Subscriber ${subscriberName} Succeed, this.__publisherMap are: ${JSON.stringify(Array.from(this._publisherMap.entries()))}`,
              "Broker",
              "info"
            );
            registeredPublisher.notifySubscriber(getIdentifier({
              name: subscriberName,
              ip: context.ip
            }), {
              updateKind: UpdateKind.UPDATE_TYPE,
              updateMode: UpdateMode.PASSIVE,
              updateSourcePaths: [
                registeredPublisher.name
              ],
              remoteTypeTarPath: registeredPublisher.remoteTypeTarPath,
              name: registeredPublisher.name
            });
            fileLog(
              // eslint-disable-next-line @ies/eden/max-calls-in-template
              `[${ActionKind.ADD_SUBSCRIBER}]: notifySubscriber Subscriber ${subscriberName}, updateMode: "PASSIVE",  updateSourcePaths: ${registeredPublisher.name}`,
              "Broker",
              "info"
            );
          }
        } catch (err) {
          const msg = error(err, ActionKind.ADD_SUBSCRIBER, "Broker");
          client.send(msg);
          client.close();
        }
      });
    });
  }
  // Trigger while consumer exit
  _removeSubscriber(context, client) {
    return __async(this, null, function* () {
      const { publishers } = context != null ? context : {};
      const subscriberIdentifier = getIdentifier({
        name: context == null ? void 0 : context.name,
        ip: context == null ? void 0 : context.ip
      });
      publishers.forEach((publisher) => {
        const { name, ip } = publisher;
        const identifier = getIdentifier({
          name,
          ip
        });
        const registeredPublisher = this._publisherMap.get(identifier);
        if (!registeredPublisher) {
          fileLog(`[${ActionKind.EXIT_SUBSCRIBER}], ${identifier} does not exit `, "Broker", "warn");
          return;
        }
        try {
          fileLog(`[${ActionKind.EXIT_SUBSCRIBER}], ${identifier} will exit `, "Broker", "INFO");
          registeredPublisher.removeSubscriber(subscriberIdentifier);
          this._clearTmpSubScriberRelation(identifier);
          if (!registeredPublisher.hasSubscribes) {
            this._publisherMap.delete(identifier);
          }
          if (!this.hasPublishers) {
            this.exit();
          }
        } catch (err) {
          const msg = error(err, ActionKind.EXIT_SUBSCRIBER, "Broker");
          client.send(msg);
          client.close();
        }
      });
    });
  }
  _removePublisher(context, client) {
    return __async(this, null, function* () {
      const { name, ip } = context != null ? context : {};
      const identifier = getIdentifier({
        name,
        ip
      });
      const publisher = this._publisherMap.get(identifier);
      if (!publisher) {
        fileLog(`[${ActionKind.EXIT_PUBLISHER}]: ${identifier}} has not been added, this action will be ingored`, "Broker", "warn");
        return;
      }
      try {
        const { subscribers } = publisher;
        subscribers.forEach((subscriber, subscriberIdentifier) => {
          this._addTmpSubScriberRelation({
            name: subscriberIdentifier,
            client: subscriber
          }, {
            name: publisher.name,
            ip: publisher.ip
          });
          fileLog(
            // eslint-disable-next-line max-len
            `[${ActionKind.EXIT_PUBLISHER}]: ${identifier} is removing , subscriber: ${subscriberIdentifier} will be add  tmpSubScriberRelation`,
            "Broker",
            "info"
          );
        });
        this._publisherMap.delete(identifier);
        fileLog(`[${ActionKind.EXIT_PUBLISHER}]: ${identifier} is removed `, "Broker", "info");
        if (!this.hasPublishers) {
          fileLog(`[${ActionKind.EXIT_PUBLISHER}]: _publisherMap is empty, all server will exit `, "Broker", "warn");
          this.exit();
        }
      } catch (err) {
        const msg = error(err, ActionKind.EXIT_PUBLISHER, "Broker");
        client.send(msg);
        client.close();
      }
    });
  }
  _addWebClient(context, client) {
    return __async(this, null, function* () {
      const { name } = context != null ? context : {};
      const identifier = getIdentifier({
        name
      });
      if (this._webClientMap.has(identifier)) {
        fileLog(`${identifier}} has been added, this action will override prev WebClient`, "Broker", "warn");
      }
      try {
        this._webClientMap.set(identifier, client);
        fileLog(`${identifier} adding WebClient Succeed`, "Broker", "info");
      } catch (err) {
        const msg = error(err, ActionKind.ADD_WEB_CLIENT, "Broker");
        client.send(msg);
        client.close();
      }
    });
  }
  _notifyWebClient(context, client) {
    return __async(this, null, function* () {
      const { name, updateMode } = context != null ? context : {};
      const identifier = getIdentifier({
        name
      });
      const webClient = this._webClientMap.get(identifier);
      if (!webClient) {
        fileLog(`[${ActionKind.NOTIFY_WEB_CLIENT}] ${identifier} has not been added, this action will be ignored`, "Broker", "warn");
        return;
      }
      try {
        const api = new ReloadWebClientAPI({
          name,
          updateMode
        });
        webClient.send(JSON.stringify(api));
        fileLog(`[${ActionKind.NOTIFY_WEB_CLIENT}] Notify ${name} WebClient Succeed`, "Broker", "info");
      } catch (err) {
        const msg = error(err, ActionKind.NOTIFY_WEB_CLIENT, "Broker");
        client.send(msg);
        client.close();
      }
    });
  }
  // app1 consumes provider1, and provider1 not launch. this._tmpSubscriberShelter at this time: {provider1: Map{subscribers: Map{app1: app1+ip+client'}, timestamp: 'xx'} }
  _addTmpSubScriberRelation(subscriber, publisher) {
    const publisherIdentifier = getIdentifier({
      name: publisher.name,
      ip: publisher.ip
    });
    const subscriberIdentifier = subscriber.name;
    const shelter = this._tmpSubscriberShelter.get(publisherIdentifier);
    if (!shelter) {
      const map = /* @__PURE__ */ new Map();
      map.set(subscriberIdentifier, subscriber);
      this._tmpSubscriberShelter.set(publisherIdentifier, {
        subscribers: map,
        timestamp: Date.now()
      });
      fileLog(`[AddTmpSubscriberRelation] ${publisherIdentifier}'s subscriber has ${subscriberIdentifier} `, "Broker", "info");
      return;
    }
    const tmpSubScriberShelterSubscriber = shelter.subscribers.get(subscriberIdentifier);
    if (tmpSubScriberShelterSubscriber) {
      fileLog(`[AddTmpSubscriberRelation] ${publisherIdentifier} and ${subscriberIdentifier} relation has been added`, "Broker", "warn");
      shelter.subscribers.set(subscriberIdentifier, subscriber);
      shelter.timestamp = Date.now();
    } else {
      fileLog(
        // eslint-disable-next-line max-len
        `AddTmpSubscriberLog ${publisherIdentifier}'s shelter has been added, update shelter.subscribers ${subscriberIdentifier}`,
        "Broker",
        "warn"
      );
      shelter.subscribers.set(subscriberIdentifier, subscriber);
    }
  }
  _getTmpSubScribers(publisherIdentifier) {
    var _a3;
    return (_a3 = this._tmpSubscriberShelter.get(publisherIdentifier)) == null ? void 0 : _a3.subscribers;
  }
  // after adding publisher, it will change the temp subscriber to regular subscriber
  _consumeTmpSubScribers(publisher, tmpSubScribers) {
    tmpSubScribers.forEach((tmpSubScriber, identifier) => {
      fileLog(`notifyTmpSubScribers ${publisher.name} will be add a subscriber: ${identifier} `, "Broker", "warn");
      publisher.addSubscriber(identifier, tmpSubScriber.client);
      publisher.notifySubscriber(identifier, {
        updateKind: UpdateKind.UPDATE_TYPE,
        updateMode: UpdateMode.PASSIVE,
        updateSourcePaths: [
          publisher.name
        ],
        remoteTypeTarPath: publisher.remoteTypeTarPath,
        name: publisher.name
      });
    });
  }
  _clearTmpSubScriberRelation(identifier) {
    this._tmpSubscriberShelter.delete(identifier);
  }
  _clearTmpSubScriberRelations() {
    this._tmpSubscriberShelter.clear();
  }
  _disconnect() {
    this._publisherMap.forEach((publisher) => {
      publisher.close();
    });
  }
  // Every day on 0/6/9/12/15//18, Publishers that have not been connected within 1.5 hours will be cleared regularly.
  // If process.env.FEDERATION_SERVER_TEST is set, it will be read at a specified time.
  _setSchedule() {
    const rule = new schedule.RecurrenceRule();
    if (Number(process.env["FEDERATION_SERVER_TEST"])) {
      const interval = Number(process.env["FEDERATION_SERVER_TEST"]) / 1e3;
      const second = [];
      for (let i = 0; i < 60; i = i + interval) {
        second.push(i);
      }
      rule.second = second;
    } else {
      rule.second = 0;
      rule.hour = [
        0,
        3,
        6,
        9,
        12,
        15,
        18
      ];
      rule.minute = 0;
    }
    const serverTest = Number(process.env["FEDERATION_SERVER_TEST"]);
    this._scheduleJob = schedule.scheduleJob(rule, () => {
      this._tmpSubscriberShelter.forEach((tmpSubscriber, identifier) => {
        fileLog(` _clearTmpSubScriberRelation ${identifier},  ${Date.now() - tmpSubscriber.timestamp >= (process.env["GARFISH_MODULE_SERVER_TEST"] ? serverTest : _Broker.DEFAULT_WAITING_TIME)}`, "Broker", "info");
        if (Date.now() - tmpSubscriber.timestamp >= (process.env["FEDERATION_SERVER_TEST"] ? serverTest : _Broker.DEFAULT_WAITING_TIME)) {
          this._clearTmpSubScriberRelation(identifier);
        }
      });
    });
  }
  _clearSchedule() {
    if (!this._scheduleJob) {
      return;
    }
    this._scheduleJob.cancel();
    this._scheduleJob = null;
  }
  _stopWhenSIGTERMOrSIGINT() {
    process.on("SIGTERM", () => {
      this.exit();
    });
    process.on("SIGINT", () => {
      this.exit();
    });
  }
  _handleUnexpectedExit() {
    process.on("unhandledRejection", (error2) => {
      console.error("Unhandled Rejection Error: ", error2);
      fileLog(`Unhandled Rejection Error: ${error2}`, "Broker", "fatal");
      process.exit(1);
    });
    process.on("uncaughtException", (error2) => {
      console.error("Unhandled Exception Error: ", error2);
      fileLog(`Unhandled Rejection Error: ${error2}`, "Broker", "fatal");
      process.exit(1);
    });
  }
  start() {
    return __async(this, null, function* () {
    });
  }
  exit() {
    const brokerExitLog = new BrokerExitLog();
    this.broadcast(JSON.stringify(brokerExitLog));
    this._disconnect();
    this._clearSchedule();
    this._clearTmpSubScriberRelations();
    this._webSocketServer && this._webSocketServer.close();
    this._secureWebSocketServer && this._secureWebSocketServer.close();
    process.exit(0);
  }
  broadcast(message) {
    var _a3, _b;
    fileLog(`[broadcast] exit info : ${JSON.stringify(message)}`, "Broker", "warn");
    (_a3 = this._webSocketServer) == null ? void 0 : _a3.clients.forEach((client) => {
      client.send(JSON.stringify(message));
    });
    (_b = this._secureWebSocketServer) == null ? void 0 : _b.clients.forEach((client) => {
      client.send(JSON.stringify(message));
    });
  }
};
__name(_Broker, "Broker");
__publicField(_Broker, "WEB_SOCKET_CONNECT_MAGIC_ID", WEB_SOCKET_CONNECT_MAGIC_ID);
__publicField(_Broker, "DEFAULT_WEB_SOCKET_PORT", DEFAULT_WEB_SOCKET_PORT);
__publicField(_Broker, "DEFAULT_SECURE_WEB_SOCKET_PORT", 16324);
__publicField(_Broker, "DEFAULT_WAITING_TIME", 1.5 * 60 * 60 * 1e3);
var Broker = _Broker;

// packages/dts-plugin/src/server/broker/createBroker.ts
import { fork } from "child_process";
import path from "path";
function createBroker() {
  const startBrokerPath = path.resolve(__dirname, "./start-broker.js");
  const sub = fork(startBrokerPath, [], {
    detached: true,
    stdio: "ignore",
    env: process.env
  });
  sub.send("start");
  sub.unref();
  return sub;
}
__name(createBroker, "createBroker");

// packages/dts-plugin/src/server/DevServer.ts
var _ModuleFederationDevServer = class _ModuleFederationDevServer {
  constructor(ctx) {
    __publicField(this, "_remotes");
    __publicField(this, "_ip");
    __publicField(this, "_name");
    __publicField(this, "_remoteTypeTarPath");
    __publicField(this, "_publishWebSocket", null);
    __publicField(this, "_subscriberWebsocketMap", {});
    __publicField(this, "_reconnect", true);
    __publicField(this, "_reconnectTimes", 0);
    __publicField(this, "_isConnected", false);
    __publicField(this, "_isReconnecting", false);
    __publicField(this, "_updateCallback", /* @__PURE__ */ __name(() => Promise.resolve(void 0), "_updateCallback"));
    const { name, remotes, remoteTypeTarPath, updateCallback } = ctx;
    this._ip = getIPV4();
    this._name = name;
    this._remotes = remotes;
    this._remoteTypeTarPath = remoteTypeTarPath;
    this._updateCallback = updateCallback;
    this._stopWhenSIGTERMOrSIGINT();
    this._handleUnexpectedExit();
    this._connectPublishToServer();
  }
  _connectPublishToServer() {
    if (!this._reconnect) {
      return;
    }
    fileLog(`Publisher:${this._name} Trying to connect to ws://${this._ip}:${Broker.DEFAULT_WEB_SOCKET_PORT}...`, MF_SERVER_IDENTIFIER, "info");
    this._publishWebSocket = new WebSocket2(`ws://${this._ip}:${Broker.DEFAULT_WEB_SOCKET_PORT}?WEB_SOCKET_CONNECT_MAGIC_ID=${Broker.WEB_SOCKET_CONNECT_MAGIC_ID}`);
    this._publishWebSocket.on("open", () => {
      var _a3;
      fileLog(`Current pid: ${process.pid}, publisher:${this._name} connected to ws://${this._ip}:${Broker.DEFAULT_WEB_SOCKET_PORT}, starting service...`, MF_SERVER_IDENTIFIER, "info");
      this._isConnected = true;
      const startGarfishModule = new AddPublisherAction({
        name: this._name,
        ip: this._ip,
        remoteTypeTarPath: this._remoteTypeTarPath
      });
      (_a3 = this._publishWebSocket) == null ? void 0 : _a3.send(JSON.stringify(startGarfishModule));
      this._connectSubscribers();
    });
    this._publishWebSocket.on("message", (message) => __async(this, null, function* () {
      var _a3, _b;
      try {
        const parsedMessage = JSON.parse(message.toString());
        if (parsedMessage.type === "Log") {
          if (parsedMessage.kind === LogKind.BrokerExitLog) {
            fileLog(`Receive broker exit signal, ${this._name} service will exit...`, MF_SERVER_IDENTIFIER, "warn");
            this._exit();
          }
        }
        if (parsedMessage.type === "API") {
          if (parsedMessage.kind === APIKind.FETCH_TYPES) {
            const { payload: { remoteInfo } } = parsedMessage;
            fileLog(`${this._name} Receive broker FETCH_TYPES, payload as follows: ${JSON.stringify(remoteInfo, null, 2)}.`, MF_SERVER_IDENTIFIER, "info");
            yield this.fetchDynamicRemoteTypes({
              remoteInfo
            });
          }
        }
      } catch (err) {
        console.error(err);
        const exitPublisher = new ExitPublisherAction({
          name: this._name,
          ip: this._ip
        });
        const exitSubscriber = new ExitSubscriberAction({
          name: this._name,
          ip: this._ip,
          publishers: this._remotes.map((remote) => ({
            name: remote.name,
            ip: remote.ip
          }))
        });
        (_a3 = this._publishWebSocket) == null ? void 0 : _a3.send(JSON.stringify(exitPublisher));
        (_b = this._publishWebSocket) == null ? void 0 : _b.send(JSON.stringify(exitSubscriber));
        fileLog("Parse messages error, ModuleFederationDevServer will exit...", MF_SERVER_IDENTIFIER, "fatal");
        this._exit();
      }
    }));
    this._publishWebSocket.on("close", (code) => {
      fileLog(`Connection closed with code ${code}.`, MF_SERVER_IDENTIFIER, "warn");
      this._publishWebSocket && this._publishWebSocket.close();
      this._publishWebSocket = null;
      if (!this._reconnect) {
        return;
      }
      const reconnectTime = fib(++this._reconnectTimes);
      fileLog(`start reconnecting to server after ${reconnectTime}s.`, MF_SERVER_IDENTIFIER, "info");
      setTimeout(() => this._connectPublishToServer(), reconnectTime * 1e3);
    });
    this._publishWebSocket.on("error", this._tryCreateBackgroundBroker.bind(this));
  }
  // Associate the remotes(Subscriber) to the Broker
  _connectSubscriberToServer(remote) {
    const { name, ip } = remote;
    fileLog(`remote module:${name} trying to connect to  ws://${ip}:${Broker.DEFAULT_WEB_SOCKET_PORT}...`, MF_SERVER_IDENTIFIER, "info");
    const identifier = getIdentifier({
      name,
      ip
    });
    this._subscriberWebsocketMap[identifier] = new WebSocket2(`ws://${ip}:${Broker.DEFAULT_WEB_SOCKET_PORT}?WEB_SOCKET_CONNECT_MAGIC_ID=${Broker.WEB_SOCKET_CONNECT_MAGIC_ID}`);
    this._subscriberWebsocketMap[identifier].on("open", () => {
      fileLog(`Current pid: ${process.pid} remote module: ${name} connected to ws://${ip}:${Broker.DEFAULT_WEB_SOCKET_PORT}, starting service...`, MF_SERVER_IDENTIFIER, "info");
      const addSubscriber = new AddSubscriberAction({
        name: this._name,
        ip: this._ip,
        publishers: [
          {
            name,
            ip
          }
        ]
      });
      this._subscriberWebsocketMap[identifier].send(JSON.stringify(addSubscriber));
    });
    this._subscriberWebsocketMap[identifier].on("message", (message) => __async(this, null, function* () {
      try {
        const parsedMessage = JSON.parse(message.toString());
        if (parsedMessage.type === "Log") {
          if (parsedMessage.kind === LogKind.BrokerExitLog) {
            fileLog(`${identifier}'s Server exit, thus ${identifier} will no longer has reload ability.`, MF_SERVER_IDENTIFIER, "warn");
            this._exit();
          }
        }
        if (parsedMessage.type === "API") {
          if (parsedMessage.kind === APIKind.UPDATE_SUBSCRIBER) {
            const { payload: { updateKind, updateSourcePaths, name: subscribeName, remoteTypeTarPath, updateMode } } = parsedMessage;
            yield this._updateSubscriber({
              remoteTypeTarPath,
              name: subscribeName,
              updateKind,
              updateMode,
              updateSourcePaths
            });
          }
        }
      } catch (err) {
        console.error(err);
        const exitSubscriber = new ExitSubscriberAction({
          name: this._name,
          ip: this._ip,
          publishers: [
            {
              name,
              ip
            }
          ]
        });
        this._subscriberWebsocketMap[identifier].send(JSON.stringify(exitSubscriber));
        fileLog(`${identifier} exit,
        error: ${err instanceof Error ? err.toString() : JSON.stringify(err)}
        `, MF_SERVER_IDENTIFIER, "warn");
      }
    }));
    this._subscriberWebsocketMap[identifier].on("close", (code) => {
      fileLog(`Connection closed with code ${code}.`, MF_SERVER_IDENTIFIER, "warn");
      this._subscriberWebsocketMap[identifier] && this._subscriberWebsocketMap[identifier].close();
      delete this._subscriberWebsocketMap[identifier];
    });
  }
  _connectSubscribers() {
    this._remotes.forEach((remote) => {
      this._connectSubscriberToServer(remote);
    });
  }
  // app1 consumes provider1. And the function will be triggered when provider1 code change.
  _updateSubscriber(options) {
    return __async(this, null, function* () {
      var _a3;
      const { updateMode, updateKind, updateSourcePaths, name, remoteTypeTarPath, remoteInfo } = options;
      fileLog(
        // eslint-disable-next-line max-len
        `[_updateSubscriber] run, options: ${JSON.stringify(options, null, 2)}`,
        MF_SERVER_IDENTIFIER,
        "warn"
      );
      if (updateMode === UpdateMode.PASSIVE && updateSourcePaths.includes(this._name)) {
        fileLog(
          // eslint-disable-next-line max-len
          `[_updateSubscriber] run, updateSourcePaths:${updateSourcePaths} includes ${this._name}, update ignore!`,
          MF_SERVER_IDENTIFIER,
          "warn"
        );
        return;
      }
      if (updateSourcePaths.slice(-1)[0] === this._name) {
        fileLog(`[_updateSubscriber] run, updateSourcePaths:${updateSourcePaths} ends is ${this._name}, update ignore!`, MF_SERVER_IDENTIFIER, "warn");
        return;
      }
      fileLog(
        // eslint-disable-next-line max-len
        `[_updateSubscriber] run, updateSourcePaths:${updateSourcePaths}, current module:${this._name}, update start...`,
        MF_SERVER_IDENTIFIER,
        "info"
      );
      yield this._updateCallback({
        name,
        updateMode,
        updateKind,
        updateSourcePaths,
        remoteTypeTarPath,
        remoteInfo
      });
      const newUpdateSourcePaths = updateSourcePaths.concat(this._name);
      const updatePublisher = new UpdatePublisherAction({
        name: this._name,
        ip: this._ip,
        updateMode: UpdateMode.PASSIVE,
        updateKind,
        updateSourcePaths: newUpdateSourcePaths,
        remoteTypeTarPath: this._remoteTypeTarPath
      });
      fileLog(
        // eslint-disable-next-line max-len
        `[_updateSubscriber] run, updateSourcePaths:${newUpdateSourcePaths}, update publisher ${this._name} start...`,
        MF_SERVER_IDENTIFIER,
        "info"
      );
      (_a3 = this._publishWebSocket) == null ? void 0 : _a3.send(JSON.stringify(updatePublisher));
    });
  }
  _tryCreateBackgroundBroker(err) {
    if (!((err == null ? void 0 : err.code) === "ECONNREFUSED" && err.port === Broker.DEFAULT_WEB_SOCKET_PORT)) {
      fileLog(`websocket error: ${err.stack}`, MF_SERVER_IDENTIFIER, "fatal");
      return;
    }
    fileLog(`Failed to connect to ws://${this._ip}:${Broker.DEFAULT_WEB_SOCKET_PORT}...`, MF_SERVER_IDENTIFIER, "fatal");
    this._isReconnecting = true;
    setTimeout(() => {
      this._isReconnecting = false;
      if (this._reconnect === false) {
        return;
      }
      fileLog("Creating new background broker...", MF_SERVER_IDENTIFIER, "warn");
      const broker = createBroker();
      broker.on("message", (message) => {
        if (message === "ready") {
          fileLog("background broker started.", MF_SERVER_IDENTIFIER, "info");
          this._reconnectTimes = 1;
          if (process.send) {
            process.send("ready");
          }
        }
      });
    }, Math.ceil(100 * Math.random()));
  }
  _stopWhenSIGTERMOrSIGINT() {
    process.on("SIGTERM", () => {
      fileLog(`Process(${process.pid}) SIGTERM, ModuleFederationDevServer will exit...`, MF_SERVER_IDENTIFIER, "warn");
      this._exit();
    });
    process.on("SIGINT", () => {
      fileLog(`Process(${process.pid}) SIGINT, ModuleFederationDevServer will exit...`, MF_SERVER_IDENTIFIER, "warn");
      this._exit();
    });
  }
  _handleUnexpectedExit() {
    process.on("unhandledRejection", (error2) => {
      if (this._isReconnecting) {
        return;
      }
      console.error("Unhandled Rejection Error: ", error2);
      fileLog(`Process(${process.pid}) unhandledRejection, garfishModuleServer will exit...`, MF_SERVER_IDENTIFIER, "error");
      this._exit();
    });
    process.on("uncaughtException", (error2) => {
      if (this._isReconnecting) {
        return;
      }
      console.error("Unhandled Exception Error: ", error2);
      fileLog(`Process(${process.pid}) uncaughtException, garfishModuleServer will exit...`, MF_SERVER_IDENTIFIER, "error");
      this._exit();
    });
  }
  _exit() {
    this._reconnect = false;
    if (this._publishWebSocket) {
      const exitPublisher = new ExitPublisherAction({
        name: this._name,
        ip: this._ip
      });
      this._publishWebSocket.send(JSON.stringify(exitPublisher));
      this._publishWebSocket.on("message", (message) => {
        const parsedMessage = JSON.parse(message.toString());
        fileLog(`[${parsedMessage.kind}]: ${JSON.stringify(parsedMessage)}`, MF_SERVER_IDENTIFIER, "info");
      });
    }
    if (this._publishWebSocket) {
      this._publishWebSocket.close();
      this._publishWebSocket = null;
    }
    process.exit(0);
  }
  exit() {
    this._exit();
  }
  update(options) {
    if (!this._publishWebSocket || !this._isConnected) {
      return;
    }
    const { updateKind, updateMode, updateSourcePaths } = options;
    fileLog(`update run, ${this._name} module update, updateKind: ${updateKind}, updateMode: ${updateMode}, updateSourcePaths: ${updateSourcePaths}`, MF_SERVER_IDENTIFIER, "info");
    if (updateKind === UpdateKind.RELOAD_PAGE) {
      const notifyWebClient = new NotifyWebClientAction({
        name: this._name,
        updateMode
      });
      this._publishWebSocket.send(JSON.stringify(notifyWebClient));
      return;
    }
    const updatePublisher = new UpdatePublisherAction({
      name: this._name,
      ip: this._ip,
      updateMode,
      updateKind,
      updateSourcePaths: [
        this._name
      ],
      remoteTypeTarPath: this._remoteTypeTarPath
    });
    this._publishWebSocket.send(JSON.stringify(updatePublisher));
  }
  fetchDynamicRemoteTypes(options) {
    return __async(this, null, function* () {
      const { remoteInfo, once } = options;
      const updateMode = UpdateMode.PASSIVE;
      const updateKind = UpdateKind.UPDATE_TYPE;
      fileLog(`fetchDynamicRemoteTypes: remoteInfo: ${JSON.stringify(remoteInfo)}`, MF_SERVER_IDENTIFIER, "info");
      yield this._updateCallback({
        name: this._name,
        updateMode,
        updateKind,
        updateSourcePaths: [],
        remoteTypeTarPath: "",
        remoteInfo,
        once
      });
      const updatePublisher = new UpdatePublisherAction({
        name: this._name,
        ip: this._ip,
        updateMode,
        updateKind,
        updateSourcePaths: [
          this._name
        ],
        remoteTypeTarPath: this._remoteTypeTarPath
      });
      this._publishWebSocket.send(JSON.stringify(updatePublisher));
    });
  }
};
__name(_ModuleFederationDevServer, "ModuleFederationDevServer");
var ModuleFederationDevServer = _ModuleFederationDevServer;

// packages/dts-plugin/src/server/createKoaServer.ts
import fs from "fs-extra";
import Koa from "koa";
function createKoaServer(options) {
  return __async(this, null, function* () {
    const { typeTarPath } = options;
    const freeport = yield getFreePort();
    const app = new Koa();
    app.use((ctx, next) => __async(this, null, function* () {
      if (ctx.path === `/${DEFAULT_TAR_NAME}`) {
        ctx.status = 200;
        ctx.body = fs.createReadStream(typeTarPath);
        ctx.response.type = "application/x-gzip";
      } else {
        yield next();
      }
    }));
    app.listen(freeport);
    return {
      server: app,
      serverAddress: `http://${getIPV4()}:${freeport}`
    };
  });
}
__name(createKoaServer, "createKoaServer");

// packages/dts-plugin/src/core/lib/archiveHandler.ts
var retrieveTypesZipPath = /* @__PURE__ */ __name((mfTypesPath, remoteOptions) => join2(mfTypesPath.replace(remoteOptions.typesFolder, ""), `${remoteOptions.typesFolder}.zip`), "retrieveTypesZipPath");
var createTypesArchive = /* @__PURE__ */ __name((tsConfig, remoteOptions) => __async(void 0, null, function* () {
  const mfTypesPath = retrieveMfTypesPath(tsConfig, remoteOptions);
  const zip = new AdmZip();
  zip.addLocalFolder(mfTypesPath);
  return zip.writeZipPromise(retrieveTypesZipPath(mfTypesPath, remoteOptions));
}), "createTypesArchive");
var downloadErrorLogger = /* @__PURE__ */ __name((destinationFolder, fileToDownload) => (reason) => {
  throw __spreadProps(__spreadValues({}, reason), {
    message: `Network error: Unable to download federated mocks for '${destinationFolder}' from '${fileToDownload}' because '${reason.message}'`
  });
}, "downloadErrorLogger");
var retrieveTypesArchiveDestinationPath = /* @__PURE__ */ __name((hostOptions, destinationFolder) => {
  return resolve2(hostOptions.context, hostOptions.typesFolder, destinationFolder);
}, "retrieveTypesArchiveDestinationPath");
var downloadTypesArchive = /* @__PURE__ */ __name((hostOptions) => {
  let retries = 0;
  return (_0) => __async(void 0, [_0], function* ([destinationFolder, fileToDownload]) {
    const destinationPath = retrieveTypesArchiveDestinationPath(hostOptions, destinationFolder);
    while (retries++ < hostOptions.maxRetries) {
      try {
        const url = fileToDownload;
        const response = yield axiosGet(url, {
          responseType: "arraybuffer"
        }).catch(downloadErrorLogger(destinationFolder, url));
        try {
          if (hostOptions.deleteTypesFolder) {
            yield rm2(destinationPath, {
              recursive: true,
              force: true
            });
          }
        } catch (error2) {
          fileLog(`Unable to remove types folder, ${error2}`, "downloadTypesArchive", "error");
        }
        const zip = new AdmZip(Buffer.from(response.data));
        zip.extractAllTo(destinationPath, true);
        return [
          destinationFolder,
          destinationPath
        ];
      } catch (error2) {
        fileLog(`Error during types archive download: ${(error2 == null ? void 0 : error2.message) || "unknown error"}`, "downloadTypesArchive", "error");
        if (retries >= hostOptions.maxRetries) {
          if (hostOptions.abortOnError !== false) {
            throw error2;
          }
          return void 0;
        }
      }
    }
  });
}, "downloadTypesArchive");

// packages/dts-plugin/src/core/configurations/hostPlugin.ts
import { parseEntry, ENCODE_NAME_PREFIX, decodeName } from "@module-federation/sdk";
import { utils } from "@module-federation/managers";
var defaultOptions = {
  typesFolder: "@mf-types",
  remoteTypesFolder: "@mf-types",
  deleteTypesFolder: true,
  maxRetries: 3,
  implementation: "",
  context: process.cwd(),
  abortOnError: true,
  consumeAPITypes: false
};
var buildZipUrl = /* @__PURE__ */ __name((hostOptions, url) => {
  const remoteUrl = new URL(url, "file:");
  const pathnameWithoutEntry = remoteUrl.pathname.split("/").slice(0, -1).join("/");
  remoteUrl.pathname = `${pathnameWithoutEntry}/${hostOptions.remoteTypesFolder}.zip`;
  return remoteUrl.protocol === "file:" ? remoteUrl.pathname : remoteUrl.href;
}, "buildZipUrl");
var buildApiTypeUrl = /* @__PURE__ */ __name((zipUrl) => {
  if (!zipUrl) {
    return void 0;
  }
  return zipUrl.replace(".zip", ".d.ts");
}, "buildApiTypeUrl");
var retrieveRemoteInfo = /* @__PURE__ */ __name((options) => {
  const { hostOptions, remoteAlias, remote } = options;
  let decodedRemote = remote;
  if (decodedRemote.startsWith(ENCODE_NAME_PREFIX)) {
    decodedRemote = decodeName(decodedRemote, ENCODE_NAME_PREFIX);
  }
  const parsedInfo = parseEntry(decodedRemote, void 0, "@");
  const url = "entry" in parsedInfo ? parsedInfo.entry : parsedInfo.name === decodedRemote ? decodedRemote : "";
  const zipUrl = url ? buildZipUrl(hostOptions, url) : "";
  return {
    name: parsedInfo.name || remoteAlias,
    url,
    zipUrl,
    apiTypeUrl: buildApiTypeUrl(zipUrl),
    alias: remoteAlias
  };
}, "retrieveRemoteInfo");
var resolveRemotes = /* @__PURE__ */ __name((hostOptions) => {
  const parsedOptions = utils.parseOptions(hostOptions.moduleFederationConfig.remotes || {}, (item, key) => ({
    remote: Array.isArray(item) ? item[0] : item,
    key
  }), (item, key) => ({
    remote: Array.isArray(item.external) ? item.external[0] : item.external,
    key
  }));
  return parsedOptions.reduce((accumulator, item) => {
    const { key, remote } = item[1];
    accumulator[key] = retrieveRemoteInfo({
      hostOptions,
      remoteAlias: key,
      remote
    });
    return accumulator;
  }, {});
}, "resolveRemotes");
var retrieveHostConfig = /* @__PURE__ */ __name((options) => {
  validateOptions(options);
  const hostOptions = __spreadValues(__spreadValues({}, defaultOptions), options);
  const mapRemotesToDownload = resolveRemotes(hostOptions);
  return {
    hostOptions,
    mapRemotesToDownload
  };
}, "retrieveHostConfig");

// packages/dts-plugin/src/core/lib/DTSManager.ts
var _a;
var DTSManager = (_a = class {
  constructor(options) {
    __publicField(this, "options");
    __publicField(this, "runtimePkgs");
    __publicField(this, "remoteAliasMap");
    __publicField(this, "loadedRemoteAPIAlias");
    __publicField(this, "extraOptions");
    __publicField(this, "updatedRemoteInfos");
    this.options = cloneDeepWith(options, (_value, key) => {
      if (key === "manifest") {
        return false;
      }
    });
    this.runtimePkgs = [
      "@module-federation/runtime",
      "@module-federation/enhanced/runtime",
      "@module-federation/runtime-tools"
    ];
    this.loadedRemoteAPIAlias = /* @__PURE__ */ new Set();
    this.remoteAliasMap = {};
    this.extraOptions = (options == null ? void 0 : options.extraOptions) || {};
    this.updatedRemoteInfos = {};
  }
  generateAPITypes(mapComponentsToExpose) {
    const exposePaths = /* @__PURE__ */ new Set();
    const packageType = Object.keys(mapComponentsToExpose).reduce((sum, exposeKey) => {
      const exposePath = path2.join(REMOTE_ALIAS_IDENTIFIER, exposeKey).split(path2.sep).join("/");
      exposePaths.add(`'${exposePath}'`);
      const curType = `T extends '${exposePath}' ? typeof import('${exposePath}') :`;
      sum = curType + sum;
      return sum;
    }, "any;");
    const exposePathKeys = [
      ...exposePaths
    ].join(" | ");
    return `
    export type RemoteKeys = ${exposePathKeys};
    type PackageType<T> = ${packageType}`;
  }
  extractRemoteTypes(options) {
    return __async(this, null, function* () {
      const { remoteOptions, tsConfig } = options;
      if (!remoteOptions.extractRemoteTypes) {
        return;
      }
      let hasRemotes = false;
      const remotes = remoteOptions.moduleFederationConfig.remotes;
      if (remotes) {
        if (Array.isArray(remotes)) {
          hasRemotes = Boolean(remotes.length);
        } else if (typeof remotes === "object") {
          hasRemotes = Boolean(Object.keys(remotes).length);
        }
      }
      const mfTypesPath = retrieveMfTypesPath(tsConfig, remoteOptions);
      if (hasRemotes) {
        const tempHostOptions = {
          moduleFederationConfig: remoteOptions.moduleFederationConfig,
          typesFolder: path2.join(mfTypesPath, "node_modules"),
          remoteTypesFolder: (remoteOptions == null ? void 0 : remoteOptions.hostRemoteTypesFolder) || remoteOptions.typesFolder,
          deleteTypesFolder: true,
          context: remoteOptions.context,
          implementation: remoteOptions.implementation,
          abortOnError: false
        };
        yield this.consumeArchiveTypes(tempHostOptions);
      }
    });
  }
  generateTypes() {
    return __async(this, null, function* () {
      var _a3;
      try {
        const { options } = this;
        if (!options.remote) {
          throw new Error("options.remote is required if you want to generateTypes");
        }
        const { remoteOptions, tsConfig, mapComponentsToExpose } = retrieveRemoteConfig(options.remote);
        if (!Object.keys(mapComponentsToExpose).length) {
          return;
        }
        yield this.extractRemoteTypes({
          remoteOptions,
          tsConfig,
          mapComponentsToExpose
        });
        yield compileTs(mapComponentsToExpose, tsConfig, remoteOptions);
        yield createTypesArchive(tsConfig, remoteOptions);
        let apiTypesPath = "";
        if (remoteOptions.generateAPITypes) {
          const apiTypes = this.generateAPITypes(mapComponentsToExpose);
          apiTypesPath = retrieveMfAPITypesPath(tsConfig, remoteOptions);
          fs2.writeFileSync(apiTypesPath, apiTypes);
        }
        try {
          if (remoteOptions.deleteTypesFolder) {
            yield rm3(retrieveMfTypesPath(tsConfig, remoteOptions), {
              recursive: true,
              force: true
            });
          }
        } catch (err) {
          if (isDebugMode()) {
            console.error(err);
          }
        }
        console.log(ansiColors.green("Federated types created correctly"));
      } catch (error2) {
        if (((_a3 = this.options.remote) == null ? void 0 : _a3.abortOnError) === false) {
          console.error(ansiColors.red(`Unable to compile federated types, ${error2}`));
        } else {
          throw error2;
        }
      }
    });
  }
  requestRemoteManifest(remoteInfo) {
    return __async(this, null, function* () {
      try {
        if (!remoteInfo.url.includes(MANIFEST_EXT)) {
          return remoteInfo;
        }
        const url = remoteInfo.url;
        const res = yield axiosGet(url);
        const manifestJson = res.data;
        if (!manifestJson.metaData.types.zip) {
          throw new Error(`Can not get ${remoteInfo.name}'s types archive url!`);
        }
        const addProtocol = /* @__PURE__ */ __name((u) => {
          if (u.startsWith("//")) {
            return `https:${u}`;
          }
          return u;
        }, "addProtocol");
        let publicPath;
        if ("publicPath" in manifestJson.metaData) {
          publicPath = manifestJson.metaData.publicPath;
        } else {
          const getPublicPath = new Function(manifestJson.metaData.getPublicPath);
          if (manifestJson.metaData.getPublicPath.startsWith("function")) {
            publicPath = getPublicPath()();
          } else {
            publicPath = getPublicPath();
          }
        }
        if (publicPath === "auto") {
          publicPath = inferAutoPublicPath(remoteInfo.url);
        }
        remoteInfo.zipUrl = new URL(path2.join(addProtocol(publicPath), manifestJson.metaData.types.zip)).href;
        if (!manifestJson.metaData.types.api) {
          console.warn(`Can not get ${remoteInfo.name}'s api types url!`);
          remoteInfo.apiTypeUrl = "";
          return remoteInfo;
        }
        remoteInfo.apiTypeUrl = new URL(path2.join(addProtocol(publicPath), manifestJson.metaData.types.api)).href;
        return remoteInfo;
      } catch (_err) {
        fileLog(`fetch manifest failed, ${_err}, ${remoteInfo.name} will be ignored`, "requestRemoteManifest", "error");
        return remoteInfo;
      }
    });
  }
  consumeTargetRemotes(hostOptions, remoteInfo) {
    return __async(this, null, function* () {
      if (!remoteInfo.zipUrl) {
        throw new Error(`Can not get ${remoteInfo.name}'s types archive url!`);
      }
      const typesDownloader = downloadTypesArchive(hostOptions);
      return typesDownloader([
        remoteInfo.alias,
        remoteInfo.zipUrl
      ]);
    });
  }
  downloadAPITypes(remoteInfo, destinationPath) {
    return __async(this, null, function* () {
      const { apiTypeUrl } = remoteInfo;
      if (!apiTypeUrl) {
        return;
      }
      try {
        const url = apiTypeUrl;
        const res = yield axiosGet(url);
        let apiTypeFile = res.data;
        apiTypeFile = apiTypeFile.replaceAll(REMOTE_ALIAS_IDENTIFIER, remoteInfo.alias);
        const filePath = path2.join(destinationPath, REMOTE_API_TYPES_FILE_NAME);
        fs2.writeFileSync(filePath, apiTypeFile);
        this.loadedRemoteAPIAlias.add(remoteInfo.alias);
      } catch (err) {
        fileLog(`Unable to download "${remoteInfo.name}" api types, ${err}`, "consumeTargetRemotes", "error");
      }
    });
  }
  consumeAPITypes(hostOptions) {
    const apiTypeFileName = path2.join(hostOptions.context, hostOptions.typesFolder, HOST_API_TYPES_FILE_NAME);
    try {
      const existedFile = fs2.readFileSync(apiTypeFileName, "utf-8");
      const existedImports = new ThirdPartyExtractor2("").collectTypeImports(existedFile);
      existedImports.forEach((existedImport) => {
        const alias = existedImport.split("./").slice(1).join("./").replace("/apis.d.ts", "");
        this.loadedRemoteAPIAlias.add(alias);
      });
    } catch (err) {
    }
    if (!this.loadedRemoteAPIAlias.size) {
      return;
    }
    const packageTypes = [];
    const remoteKeys = [];
    const importTypeStr = [
      ...this.loadedRemoteAPIAlias
    ].sort().map((alias, index) => {
      const remoteKey = `RemoteKeys_${index}`;
      const packageType = `PackageType_${index}`;
      packageTypes.push(`T extends ${remoteKey} ? ${packageType}<T>`);
      remoteKeys.push(remoteKey);
      return `import type { PackageType as ${packageType},RemoteKeys as ${remoteKey} } from './${alias}/apis.d.ts';`;
    }).join("\n");
    const remoteKeysStr = `type RemoteKeys = ${remoteKeys.join(" | ")};`;
    const packageTypesStr = `type PackageType<T, Y=any> = ${[
      ...packageTypes,
      "Y"
    ].join(" :\n")} ;`;
    const pkgsDeclareStr = this.runtimePkgs.map((pkg) => {
      return `declare module "${pkg}" {
      ${remoteKeysStr}
      ${packageTypesStr}
      export function loadRemote<T extends RemoteKeys,Y>(packageName: T): Promise<PackageType<T, Y>>;
      export function loadRemote<T extends string,Y>(packageName: T): Promise<PackageType<T, Y>>;
    }`;
    }).join("\n");
    const fileStr = `${importTypeStr}
    ${pkgsDeclareStr}
    `;
    fs2.writeFileSync(path2.join(hostOptions.context, hostOptions.typesFolder, HOST_API_TYPES_FILE_NAME), fileStr);
  }
  consumeArchiveTypes(options) {
    return __async(this, null, function* () {
      const { hostOptions, mapRemotesToDownload } = retrieveHostConfig(options);
      const downloadPromises = Object.entries(mapRemotesToDownload).map((item) => __async(this, null, function* () {
        const remoteInfo = item[1];
        if (!this.remoteAliasMap[remoteInfo.alias]) {
          const requiredRemoteInfo = yield this.requestRemoteManifest(remoteInfo);
          this.remoteAliasMap[remoteInfo.alias] = requiredRemoteInfo;
        }
        return this.consumeTargetRemotes(hostOptions, this.remoteAliasMap[remoteInfo.alias]);
      }));
      const downloadPromisesResult = yield Promise.allSettled(downloadPromises);
      return {
        hostOptions,
        downloadPromisesResult
      };
    });
  }
  consumeTypes() {
    return __async(this, null, function* () {
      var _a3;
      try {
        const { options } = this;
        if (!options.host) {
          throw new Error("options.host is required if you want to consumeTypes");
        }
        const { mapRemotesToDownload } = retrieveHostConfig(options.host);
        if (!Object.keys(mapRemotesToDownload).length) {
          return;
        }
        const { downloadPromisesResult, hostOptions } = yield this.consumeArchiveTypes(options.host);
        if (hostOptions.consumeAPITypes) {
          yield Promise.all(downloadPromisesResult.map((item) => __async(this, null, function* () {
            if (item.status === "rejected" || !item.value) {
              return;
            }
            const [alias, destinationPath] = item.value;
            const remoteInfo = this.remoteAliasMap[alias];
            if (!remoteInfo) {
              return;
            }
            yield this.downloadAPITypes(remoteInfo, destinationPath);
          })));
          this.consumeAPITypes(hostOptions);
        }
        console.log(ansiColors.green("Federated types extraction completed"));
      } catch (err) {
        if (((_a3 = this.options.host) == null ? void 0 : _a3.abortOnError) === false) {
          fileLog(`Unable to consume federated types, ${err}`, "consumeTypes", "error");
        } else {
          throw err;
        }
      }
    });
  }
  updateTypes(options) {
    return __async(this, null, function* () {
      var _a3, _b, _c;
      try {
        const { remoteName, updateMode, remoteInfo: updatedRemoteInfo, once } = options;
        const hostName = (_c = (_b = (_a3 = this.options) == null ? void 0 : _a3.host) == null ? void 0 : _b.moduleFederationConfig) == null ? void 0 : _c.name;
        fileLog(`updateTypes options:, ${JSON.stringify(options, null, 2)}`, "consumeTypes", "info");
        if (updateMode === UpdateMode.POSITIVE && remoteName === hostName) {
          if (!this.options.remote) {
            return;
          }
          yield this.generateTypes();
        } else {
          const { remoteAliasMap } = this;
          if (!this.options.host) {
            return;
          }
          const { hostOptions, mapRemotesToDownload } = retrieveHostConfig(this.options.host);
          const loadedRemoteInfo = Object.values(remoteAliasMap).find((i) => i.name === remoteName);
          const consumeTypes2 = /* @__PURE__ */ __name((requiredRemoteInfo) => __async(this, null, function* () {
            const [_alias, destinationPath] = yield this.consumeTargetRemotes(hostOptions, requiredRemoteInfo);
            yield this.downloadAPITypes(requiredRemoteInfo, destinationPath);
          }), "consumeTypes");
          if (!loadedRemoteInfo) {
            const remoteInfo = Object.values(mapRemotesToDownload).find((item) => {
              return item.name === remoteName;
            });
            if (remoteInfo) {
              if (!this.remoteAliasMap[remoteInfo.alias]) {
                const requiredRemoteInfo = yield this.requestRemoteManifest(remoteInfo);
                this.remoteAliasMap[remoteInfo.alias] = requiredRemoteInfo;
              }
              yield consumeTypes2(this.remoteAliasMap[remoteInfo.alias]);
            } else if (updatedRemoteInfo) {
              const consumeDynamicRemoteTypes = /* @__PURE__ */ __name(() => __async(this, null, function* () {
                yield consumeTypes2(this.updatedRemoteInfos[updatedRemoteInfo.name]);
                this.consumeAPITypes(hostOptions);
              }), "consumeDynamicRemoteTypes");
              if (!this.updatedRemoteInfos[updatedRemoteInfo.name]) {
                const parsedRemoteInfo = retrieveRemoteInfo({
                  hostOptions,
                  remoteAlias: updatedRemoteInfo.alias || updatedRemoteInfo.name,
                  remote: updatedRemoteInfo.url
                });
                fileLog(`start request manifest`, "consumeTypes", "info");
                this.updatedRemoteInfos[updatedRemoteInfo.name] = yield this.requestRemoteManifest(parsedRemoteInfo);
                fileLog(`end request manifest, this.updatedRemoteInfos[updatedRemoteInfo.name]: ${JSON.stringify(this.updatedRemoteInfos[updatedRemoteInfo.name], null, 2)}`, "consumeTypes", "info");
                yield consumeDynamicRemoteTypes();
              }
              if (!once && this.updatedRemoteInfos[updatedRemoteInfo.name]) {
                yield consumeDynamicRemoteTypes();
              }
            }
          } else {
            yield consumeTypes2(loadedRemoteInfo);
          }
        }
      } catch (err) {
        fileLog(`updateTypes fail, ${err}`, "updateTypes", "error");
      }
    });
  }
}, __name(_a, "DTSManager"), _a);

// packages/dts-plugin/src/core/lib/utils.ts
function getDTSManagerConstructor(implementation) {
  if (implementation) {
    const NewConstructor = __require(implementation);
    return NewConstructor.default ? NewConstructor.default : NewConstructor;
  }
  return DTSManager;
}
__name(getDTSManagerConstructor, "getDTSManagerConstructor");
var validateOptions = /* @__PURE__ */ __name((options) => {
  if (!options.moduleFederationConfig) {
    throw new Error("moduleFederationConfig is required");
  }
}, "validateOptions");
function retrieveTypesAssetsInfo(options) {
  let apiTypesPath = "";
  let zipTypesPath = "";
  try {
    const { tsConfig, remoteOptions, mapComponentsToExpose } = retrieveRemoteConfig(options);
    if (!Object.keys(mapComponentsToExpose).length) {
      return {
        apiTypesPath,
        zipTypesPath,
        zipName: "",
        apiFileName: ""
      };
    }
    const mfTypesPath = retrieveMfTypesPath(tsConfig, remoteOptions);
    zipTypesPath = retrieveTypesZipPath(mfTypesPath, remoteOptions);
    if (remoteOptions.generateAPITypes) {
      apiTypesPath = retrieveMfAPITypesPath(tsConfig, remoteOptions);
    }
    return {
      apiTypesPath,
      zipTypesPath,
      zipName: path3.basename(zipTypesPath),
      apiFileName: path3.basename(apiTypesPath)
    };
  } catch (err) {
    console.error(ansiColors2.red(`Unable to compile federated types, ${err}`));
    return {
      apiTypesPath: "",
      zipTypesPath: "",
      zipName: "",
      apiFileName: ""
    };
  }
}
__name(retrieveTypesAssetsInfo, "retrieveTypesAssetsInfo");
function isDebugMode() {
  return Boolean(process.env["FEDERATION_DEBUG"]) || process.env["NODE_ENV"] === "test";
}
__name(isDebugMode, "isDebugMode");
var isTSProject = /* @__PURE__ */ __name((dtsOptions, context = process.cwd()) => {
  if (dtsOptions === false) {
    return false;
  }
  try {
    let filepath = "";
    if (typeof dtsOptions === "object" && dtsOptions.tsConfigPath) {
      filepath = dtsOptions.tsConfigPath;
    } else {
      filepath = path3.resolve(context, "./tsconfig.json");
    }
    if (!path3.isAbsolute(filepath)) {
      filepath = path3.resolve(context, filepath);
    }
    return fs3.existsSync(filepath);
  } catch (err) {
    return false;
  }
}, "isTSProject");
function axiosGet(url, config) {
  return __async(this, null, function* () {
    const httpAgent = new http.Agent({
      family: 4
    });
    const httpsAgent = new https.Agent({
      family: 4
    });
    return axios.get(url, __spreadValues({
      httpAgent,
      httpsAgent
    }, config));
  });
}
__name(axiosGet, "axiosGet");

// packages/dts-plugin/src/core/configurations/remotePlugin.ts
var defaultOptions2 = {
  tsConfigPath: "./tsconfig.json",
  typesFolder: "@mf-types",
  compiledTypesFolder: "compiled-types",
  hostRemoteTypesFolder: "@mf-types",
  deleteTypesFolder: true,
  additionalFilesToCompile: [],
  compilerInstance: "tsc",
  compileInChildProcess: false,
  implementation: "",
  generateAPITypes: false,
  context: process.cwd(),
  abortOnError: true,
  extractRemoteTypes: false,
  extractThirdParty: false
};
function getEffectiveRootDir(parsedCommandLine) {
  const compilerOptions = parsedCommandLine.options;
  if (compilerOptions.rootDir) {
    return compilerOptions.rootDir;
  }
  const files = parsedCommandLine.fileNames;
  if (files.length > 0) {
    const commonRoot = files.map((file) => dirname2(file)).reduce((commonPath, fileDir) => {
      while (!fileDir.startsWith(commonPath)) {
        commonPath = dirname2(commonPath);
      }
      return commonPath;
    }, files[0]);
    return commonRoot;
  }
  throw new Error("Can not get effective rootDir, please set compilerOptions.rootDir !");
}
__name(getEffectiveRootDir, "getEffectiveRootDir");
var readTsConfig = /* @__PURE__ */ __name(({ tsConfigPath, typesFolder, compiledTypesFolder, context, additionalFilesToCompile }, mapComponentsToExpose) => {
  const resolvedTsConfigPath = resolve3(context, tsConfigPath);
  const readResult = typescript.readConfigFile(resolvedTsConfigPath, typescript.sys.readFile);
  if (readResult.error) {
    throw new Error(readResult.error.messageText.toString());
  }
  const rawTsConfigJson = readResult.config;
  const configContent = typescript.parseJsonConfigFileContent(rawTsConfigJson, typescript.sys, dirname2(resolvedTsConfigPath));
  const rootDir = getEffectiveRootDir(configContent);
  const outDir = resolve3(context, configContent.options.outDir || "dist", typesFolder, compiledTypesFolder);
  const defaultCompilerOptions = {
    rootDir,
    emitDeclarationOnly: true,
    noEmit: false,
    declaration: true,
    outDir
  };
  rawTsConfigJson.compilerOptions = rawTsConfigJson.compilerOptions || {};
  rawTsConfigJson.compilerOptions = __spreadValues(__spreadValues({}, rawTsConfigJson.compilerOptions), defaultCompilerOptions);
  const filesToCompile = [
    ...Object.values(mapComponentsToExpose),
    ...additionalFilesToCompile
  ];
  rawTsConfigJson.include = [];
  rawTsConfigJson.files = filesToCompile;
  rawTsConfigJson.exclude = [];
  "references" in rawTsConfigJson && delete rawTsConfigJson.references;
  const extendsPath = rawTsConfigJson.extends;
  if (extendsPath && extendsPath.startsWith(".")) {
    rawTsConfigJson.extends = resolve3(context, extendsPath);
  }
  return rawTsConfigJson;
}, "readTsConfig");
var TS_EXTENSIONS = [
  "ts",
  "tsx",
  "vue",
  "svelte"
];
var resolveWithExtension = /* @__PURE__ */ __name((exposedPath, context) => {
  if (extname2(exposedPath)) {
    return resolve3(context, exposedPath);
  }
  for (const extension of TS_EXTENSIONS) {
    const exposedPathWithExtension = resolve3(context, `${exposedPath}.${extension}`);
    if (existsSync2(exposedPathWithExtension)) {
      return exposedPathWithExtension;
    }
  }
  return void 0;
}, "resolveWithExtension");
var resolveExposes = /* @__PURE__ */ __name((remoteOptions) => {
  const parsedOptions = utils2.parseOptions(remoteOptions.moduleFederationConfig.exposes || {}, (item, key) => ({
    exposePath: Array.isArray(item) ? item[0] : item,
    key
  }), (item, key) => ({
    exposePath: Array.isArray(item.import) ? item.import[0] : item.import[0],
    key
  }));
  return parsedOptions.reduce((accumulator, item) => {
    const { exposePath, key } = item[1];
    accumulator[key] = resolveWithExtension(exposePath, remoteOptions.context) || resolveWithExtension(join3(exposePath, "index"), remoteOptions.context) || exposePath;
    return accumulator;
  }, {});
}, "resolveExposes");
var retrieveRemoteConfig = /* @__PURE__ */ __name((options) => {
  validateOptions(options);
  const remoteOptions = __spreadValues(__spreadValues({}, defaultOptions2), options);
  const mapComponentsToExpose = resolveExposes(remoteOptions);
  const tsConfig = readTsConfig(remoteOptions, mapComponentsToExpose);
  return {
    tsConfig,
    mapComponentsToExpose,
    remoteOptions
  };
}, "retrieveRemoteConfig");

// packages/dts-plugin/src/core/lib/generateTypes.ts
function generateTypes(options) {
  return __async(this, null, function* () {
    var _a3;
    const DTSManagerConstructor = getDTSManagerConstructor((_a3 = options.remote) == null ? void 0 : _a3.implementation);
    const dtsManager = new DTSManagerConstructor(options);
    return dtsManager.generateTypes();
  });
}
__name(generateTypes, "generateTypes");

// packages/dts-plugin/src/core/lib/DtsWorker.ts
import path4 from "path";
import cloneDeepWith2 from "lodash.clonedeepwith";

// packages/dts-plugin/src/core/rpc/index.ts
var rpc_exports = {};
__export(rpc_exports, {
  RpcExitError: () => RpcExitError,
  RpcGMCallTypes: () => RpcGMCallTypes,
  createRpcWorker: () => createRpcWorker,
  exposeRpc: () => exposeRpc,
  getRpcWorkerData: () => getRpcWorkerData,
  wrapRpc: () => wrapRpc
});

// packages/dts-plugin/src/core/rpc/expose-rpc.ts
import process2 from "process";

// packages/dts-plugin/src/core/rpc/types.ts
var RpcGMCallTypes;
(function(RpcGMCallTypes2) {
  RpcGMCallTypes2["CALL"] = "mf_call";
  RpcGMCallTypes2["RESOLVE"] = "mf_resolve";
  RpcGMCallTypes2["REJECT"] = "mf_reject";
  RpcGMCallTypes2["EXIT"] = "mf_exit";
})(RpcGMCallTypes || (RpcGMCallTypes = {}));

// packages/dts-plugin/src/core/rpc/expose-rpc.ts
function exposeRpc(fn) {
  const sendMessage = /* @__PURE__ */ __name((message) => new Promise((resolve4, reject) => {
    if (!process2.send) {
      reject(new Error(`Process ${process2.pid} doesn't have IPC channels`));
    } else if (!process2.connected) {
      reject(new Error(`Process ${process2.pid} doesn't have open IPC channels`));
    } else {
      process2.send(message, void 0, void 0, (error2) => {
        if (error2) {
          reject(error2);
        } else {
          resolve4(void 0);
        }
      });
    }
  }), "sendMessage");
  const handleMessage = /* @__PURE__ */ __name((message) => __async(this, null, function* () {
    if (message.type === RpcGMCallTypes.CALL) {
      if (!process2.send) {
        return;
      }
      let value, error2;
      try {
        value = yield fn(...message.args);
      } catch (fnError) {
        error2 = fnError;
      }
      try {
        if (error2) {
          yield sendMessage({
            type: RpcGMCallTypes.REJECT,
            id: message.id,
            error: error2
          });
        } else {
          yield sendMessage({
            type: RpcGMCallTypes.RESOLVE,
            id: message.id,
            value
          });
        }
      } catch (sendError) {
        if (error2) {
          if (error2 instanceof Error) {
            console.error(error2);
          }
        }
        console.error(sendError);
      }
    }
  }), "handleMessage");
  process2.on("message", handleMessage);
}
__name(exposeRpc, "exposeRpc");

// packages/dts-plugin/src/core/rpc/rpc-error.ts
var _a2;
var RpcExitError = (_a2 = class extends Error {
  constructor(message, code, signal) {
    super(message);
    __publicField(this, "code");
    __publicField(this, "signal");
    this.code = code;
    this.signal = signal;
    this.name = "RpcExitError";
  }
}, __name(_a2, "RpcExitError"), _a2);

// packages/dts-plugin/src/core/rpc/wrap-rpc.ts
function createControlledPromise() {
  let resolve4 = /* @__PURE__ */ __name(() => void 0, "resolve");
  let reject = /* @__PURE__ */ __name(() => void 0, "reject");
  const promise = new Promise((aResolve, aReject) => {
    resolve4 = aResolve;
    reject = aReject;
  });
  return {
    promise,
    resolve: resolve4,
    reject
  };
}
__name(createControlledPromise, "createControlledPromise");
function wrapRpc(childProcess, options) {
  return (...args) => __async(this, null, function* () {
    if (!childProcess.send) {
      throw new Error(`Process ${childProcess.pid} doesn't have IPC channels`);
    } else if (!childProcess.connected) {
      throw new Error(`Process ${childProcess.pid} doesn't have open IPC channels`);
    }
    const { id, once } = options;
    const { promise: resultPromise, resolve: resolveResult, reject: rejectResult } = createControlledPromise();
    const { promise: sendPromise, resolve: resolveSend, reject: rejectSend } = createControlledPromise();
    const handleMessage = /* @__PURE__ */ __name((message) => {
      if ((message == null ? void 0 : message.id) === id) {
        if (message.type === RpcGMCallTypes.RESOLVE) {
          resolveResult(message.value);
        } else if (message.type === RpcGMCallTypes.REJECT) {
          rejectResult(message.error);
        }
      }
      if (once && (childProcess == null ? void 0 : childProcess.kill)) {
        childProcess.kill("SIGTERM");
      }
    }, "handleMessage");
    const handleClose = /* @__PURE__ */ __name((code, signal) => {
      rejectResult(new RpcExitError(code ? `Process ${childProcess.pid} exited with code ${code}${signal ? ` [${signal}]` : ""}` : `Process ${childProcess.pid} exited${signal ? ` [${signal}]` : ""}`, code, signal));
      removeHandlers();
    }, "handleClose");
    const removeHandlers = /* @__PURE__ */ __name(() => {
      childProcess.off("message", handleMessage);
      childProcess.off("close", handleClose);
    }, "removeHandlers");
    if (once) {
      childProcess.once("message", handleMessage);
    } else {
      childProcess.on("message", handleMessage);
    }
    childProcess.on("close", handleClose);
    childProcess.send({
      type: RpcGMCallTypes.CALL,
      id,
      args
    }, (error2) => {
      if (error2) {
        rejectSend(error2);
        removeHandlers();
      } else {
        resolveSend(void 0);
      }
    });
    return sendPromise.then(() => resultPromise);
  });
}
__name(wrapRpc, "wrapRpc");

// packages/dts-plugin/src/core/rpc/rpc-worker.ts
import * as child_process from "child_process";
import * as process3 from "process";
import { randomUUID as randomUUID2 } from "crypto";
var FEDERATION_WORKER_DATA_ENV_KEY = "VMOK_WORKER_DATA_ENV";
function createRpcWorker(modulePath, data, memoryLimit, once) {
  const options = {
    env: __spreadProps(__spreadValues({}, process3.env), {
      [FEDERATION_WORKER_DATA_ENV_KEY]: JSON.stringify(data || {})
    }),
    stdio: [
      "inherit",
      "inherit",
      "inherit",
      "ipc"
    ],
    serialization: "advanced"
  };
  if (memoryLimit) {
    options.execArgv = [
      `--max-old-space-size=${memoryLimit}`
    ];
  }
  let childProcess, remoteMethod;
  const id = randomUUID2();
  const worker = {
    connect(...args) {
      if (childProcess && !childProcess.connected) {
        childProcess.send({
          type: RpcGMCallTypes.EXIT,
          id
        });
        childProcess = void 0;
        remoteMethod = void 0;
      }
      if (!(childProcess == null ? void 0 : childProcess.connected)) {
        childProcess = child_process.fork(modulePath, options);
        remoteMethod = wrapRpc(childProcess, {
          id,
          once
        });
      }
      if (!remoteMethod) {
        return Promise.reject(new Error("Worker is not connected - cannot perform RPC."));
      }
      return remoteMethod(...args);
    },
    terminate() {
      var _a3;
      (_a3 = childProcess == null ? void 0 : childProcess.send) == null ? void 0 : _a3.call(childProcess, {
        type: RpcGMCallTypes.EXIT,
        id
      });
      childProcess = void 0;
      remoteMethod = void 0;
    },
    get connected() {
      return Boolean(childProcess == null ? void 0 : childProcess.connected);
    },
    get process() {
      return childProcess;
    },
    get id() {
      return id;
    }
  };
  return worker;
}
__name(createRpcWorker, "createRpcWorker");
function getRpcWorkerData() {
  return JSON.parse(process3.env[FEDERATION_WORKER_DATA_ENV_KEY] || "{}");
}
__name(getRpcWorkerData, "getRpcWorkerData");

// packages/dts-plugin/src/core/lib/DtsWorker.ts
var _DtsWorker = class _DtsWorker {
  constructor(options) {
    __publicField(this, "rpcWorker");
    __publicField(this, "_options");
    __publicField(this, "_res");
    this._options = cloneDeepWith2(options, (_value, key) => {
      if (key === "manifest") {
        return false;
      }
    });
    this.removeUnSerializationOptions();
    this.rpcWorker = createRpcWorker(path4.resolve(__dirname, "./fork-generate-dts.js"), {}, void 0, true);
    this._res = this.rpcWorker.connect(this._options);
  }
  removeUnSerializationOptions() {
    var _a3, _b, _c, _d, _e, _f, _g, _h;
    if ((_b = (_a3 = this._options.remote) == null ? void 0 : _a3.moduleFederationConfig) == null ? void 0 : _b.manifest) {
      (_d = (_c = this._options.remote) == null ? void 0 : _c.moduleFederationConfig) == null ? true : delete _d.manifest;
    }
    if ((_f = (_e = this._options.host) == null ? void 0 : _e.moduleFederationConfig) == null ? void 0 : _f.manifest) {
      (_h = (_g = this._options.host) == null ? void 0 : _g.moduleFederationConfig) == null ? true : delete _h.manifest;
    }
  }
  get controlledPromise() {
    const ensureChildProcessExit = /* @__PURE__ */ __name(() => {
      var _a3;
      try {
        const pid = (_a3 = this.rpcWorker.process) == null ? void 0 : _a3.pid;
        const rootPid = process.pid;
        if (pid && rootPid !== pid) {
          process.kill(pid, 0);
        }
      } catch (error2) {
        if (isDebugMode()) {
          console.error(error2);
        }
      }
    }, "ensureChildProcessExit");
    return Promise.resolve(this._res).then(() => {
      this.exit();
      ensureChildProcessExit();
    }).catch((err) => {
      if (isDebugMode()) {
        console.error(err);
      }
      ensureChildProcessExit();
    });
  }
  exit() {
    var _a3;
    (_a3 = this.rpcWorker) == null ? void 0 : _a3.terminate();
  }
};
__name(_DtsWorker, "DtsWorker");
var DtsWorker = _DtsWorker;

// packages/dts-plugin/src/core/lib/generateTypesInChildProcess.ts
function generateTypesInChildProcess(options) {
  return __async(this, null, function* () {
    const dtsWorker = new DtsWorker(options);
    return dtsWorker.controlledPromise;
  });
}
__name(generateTypesInChildProcess, "generateTypesInChildProcess");

// packages/dts-plugin/src/core/lib/consumeTypes.ts
function consumeTypes(options) {
  return __async(this, null, function* () {
    var _a3;
    const DTSManagerConstructor = getDTSManagerConstructor((_a3 = options.host) == null ? void 0 : _a3.implementation);
    const dtsManager = new DTSManagerConstructor(options);
    yield dtsManager.consumeTypes();
  });
}
__name(consumeTypes, "consumeTypes");

export {
  retrieveMfTypesPath,
  retrieveOriginalOutDir,
  fileLog,
  getIPV4,
  Broker,
  ModuleFederationDevServer,
  createKoaServer,
  retrieveTypesZipPath,
  retrieveHostConfig,
  DTSManager,
  getDTSManagerConstructor,
  validateOptions,
  retrieveTypesAssetsInfo,
  isTSProject,
  retrieveRemoteConfig,
  generateTypes,
  RpcGMCallTypes,
  exposeRpc,
  rpc_exports,
  DtsWorker,
  generateTypesInChildProcess,
  consumeTypes
};
