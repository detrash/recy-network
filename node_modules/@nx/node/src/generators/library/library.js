"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.libraryGenerator = libraryGenerator;
exports.libraryGeneratorInternal = libraryGeneratorInternal;
const devkit_1 = require("@nx/devkit");
const project_name_and_root_utils_1 = require("@nx/devkit/src/generators/project-name-and-root-utils");
const js_1 = require("@nx/js");
const add_swc_config_1 = require("@nx/js/src/utils/swc/add-swc-config");
const add_swc_dependencies_1 = require("@nx/js/src/utils/swc/add-swc-dependencies");
const path_1 = require("path");
const versions_1 = require("../../utils/versions");
const init_1 = require("../init/init");
const target_defaults_utils_1 = require("@nx/devkit/src/generators/target-defaults-utils");
async function libraryGenerator(tree, schema) {
    return await libraryGeneratorInternal(tree, {
        addPlugin: false,
        projectNameAndRootFormat: 'derived',
        ...schema,
    });
}
async function libraryGeneratorInternal(tree, schema) {
    const options = await normalizeOptions(tree, schema);
    const tasks = [
        await (0, init_1.initGenerator)(tree, {
            ...options,
            skipFormat: true,
        }),
    ];
    if (options.publishable === true && !schema.importPath) {
        throw new Error(`For publishable libs you have to provide a proper "--importPath" which needs to be a valid npm package name (e.g. my-awesome-lib or @myorg/my-lib)`);
    }
    const libraryInstall = await (0, js_1.libraryGenerator)(tree, {
        ...options,
        bundler: schema.buildable ? 'tsc' : 'none',
        includeBabelRc: schema.babelJest,
        importPath: options.importPath,
        testEnvironment: 'node',
        skipFormat: true,
        setParserOptionsProject: options.setParserOptionsProject,
    });
    tasks.push(libraryInstall);
    createFiles(tree, options);
    if (options.js) {
        (0, devkit_1.updateTsConfigsToJs)(tree, options);
    }
    updateProject(tree, options);
    tasks.push(ensureDependencies(tree));
    if (!schema.skipFormat) {
        await (0, devkit_1.formatFiles)(tree);
    }
    return (0, devkit_1.runTasksInSerial)(...tasks);
}
exports.default = libraryGenerator;
async function normalizeOptions(tree, options) {
    const { projectName, names: projectNames, projectRoot, importPath, projectNameAndRootFormat, } = await (0, project_name_and_root_utils_1.determineProjectNameAndRootOptions)(tree, {
        name: options.name,
        projectType: 'library',
        directory: options.directory,
        importPath: options.importPath,
        projectNameAndRootFormat: options.projectNameAndRootFormat,
        callingGenerator: '@nx/node:library',
    });
    options.projectNameAndRootFormat = projectNameAndRootFormat;
    const nxJson = (0, devkit_1.readNxJson)(tree);
    const addPluginDefault = process.env.NX_ADD_PLUGINS !== 'false' &&
        nxJson.useInferencePlugins !== false;
    options.addPlugin ??= addPluginDefault;
    const fileName = getCaseAwareFileName({
        fileName: options.simpleModuleName
            ? projectNames.projectSimpleName
            : projectNames.projectFileName,
        pascalCaseFiles: options.pascalCaseFiles,
    });
    const parsedTags = options.tags
        ? options.tags.split(',').map((s) => s.trim())
        : [];
    return {
        ...options,
        fileName,
        projectName,
        projectRoot,
        parsedTags,
        importPath,
    };
}
function getCaseAwareFileName(options) {
    const normalized = (0, devkit_1.names)(options.fileName);
    return options.pascalCaseFiles ? normalized.className : normalized.fileName;
}
function createFiles(tree, options) {
    const { className, name, propertyName } = (0, devkit_1.names)(options.fileName);
    (0, devkit_1.generateFiles)(tree, (0, path_1.join)(__dirname, './files/lib'), options.projectRoot, {
        ...options,
        className,
        name,
        propertyName,
        tmpl: '',
        offsetFromRoot: (0, devkit_1.offsetFromRoot)(options.projectRoot),
    });
    if (options.unitTestRunner === 'none') {
        tree.delete((0, path_1.join)(options.projectRoot, `./src/lib/${options.fileName}.spec.ts`));
    }
    if (!options.publishable && !options.buildable) {
        tree.delete((0, path_1.join)(options.projectRoot, 'package.json'));
    }
    if (options.js) {
        (0, devkit_1.toJS)(tree);
    }
}
function updateProject(tree, options) {
    if (!options.publishable && !options.buildable) {
        return;
    }
    const project = (0, devkit_1.readProjectConfiguration)(tree, options.projectName);
    const rootProject = options.projectRoot === '.' || options.projectRoot === '';
    project.targets = project.targets || {};
    (0, target_defaults_utils_1.addBuildTargetDefaults)(tree, `@nx/js:${options.compiler}`);
    project.targets.build = {
        executor: `@nx/js:${options.compiler}`,
        outputs: ['{options.outputPath}'],
        options: {
            outputPath: (0, devkit_1.joinPathFragments)('dist', rootProject ? options.projectName : options.projectRoot),
            tsConfig: `${options.projectRoot}/tsconfig.lib.json`,
            packageJson: `${options.projectRoot}/package.json`,
            main: `${options.projectRoot}/src/index` + (options.js ? '.js' : '.ts'),
            assets: [`${options.projectRoot}/*.md`],
        },
    };
    if (options.compiler === 'swc') {
        (0, add_swc_dependencies_1.addSwcDependencies)(tree);
        (0, add_swc_config_1.addSwcConfig)(tree, options.projectRoot);
    }
    if (options.rootDir) {
        project.targets.build.options.srcRootForCompilationRoot = options.rootDir;
    }
    (0, devkit_1.updateProjectConfiguration)(tree, options.projectName, project);
}
function ensureDependencies(tree) {
    return (0, devkit_1.addDependenciesToPackageJson)(tree, { tslib: versions_1.tslibVersion }, { '@types/node': versions_1.typesNodeVersion });
}
