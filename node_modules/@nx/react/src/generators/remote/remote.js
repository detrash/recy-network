"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addModuleFederationFiles = addModuleFederationFiles;
exports.remoteGenerator = remoteGenerator;
exports.remoteGeneratorInternal = remoteGeneratorInternal;
const path_1 = require("path");
const devkit_1 = require("@nx/devkit");
const normalize_options_1 = require("../application/lib/normalize-options");
const application_1 = require("../application/application");
const update_host_with_remote_1 = require("./lib/update-host-with-remote");
const update_module_federation_project_1 = require("../../rules/update-module-federation-project");
const setup_ssr_1 = require("../setup-ssr/setup-ssr");
const setup_ssr_for_remote_1 = require("./lib/setup-ssr-for-remote");
const setup_tspath_for_remote_1 = require("./lib/setup-tspath-for-remote");
const add_remote_to_dynamic_host_1 = require("./lib/add-remote-to-dynamic-host");
const add_mf_env_to_inputs_1 = require("../../utils/add-mf-env-to-inputs");
const maybe_js_1 = require("../../utils/maybe-js");
const js_1 = require("@nx/js");
const versions_1 = require("../../utils/versions");
function addModuleFederationFiles(host, options) {
    const templateVariables = {
        ...(0, devkit_1.names)(options.name),
        ...options,
        tmpl: '',
    };
    (0, devkit_1.generateFiles)(host, (0, path_1.join)(__dirname, `./files/${options.js ? 'common' : 'common-ts'}`), options.appProjectRoot, templateVariables);
    const pathToModuleFederationFiles = options.typescriptConfiguration
        ? 'module-federation-ts'
        : 'module-federation';
    (0, devkit_1.generateFiles)(host, (0, path_1.join)(__dirname, `./files/${pathToModuleFederationFiles}`), options.appProjectRoot, templateVariables);
    if (options.typescriptConfiguration) {
        const pathToWebpackConfig = (0, devkit_1.joinPathFragments)(options.appProjectRoot, 'webpack.config.js');
        const pathToWebpackProdConfig = (0, devkit_1.joinPathFragments)(options.appProjectRoot, 'webpack.config.prod.js');
        if (host.exists(pathToWebpackConfig)) {
            host.delete(pathToWebpackConfig);
        }
        if (host.exists(pathToWebpackProdConfig)) {
            host.delete(pathToWebpackProdConfig);
        }
    }
}
async function remoteGenerator(host, schema) {
    return await remoteGeneratorInternal(host, {
        projectNameAndRootFormat: 'derived',
        ...schema,
    });
}
async function remoteGeneratorInternal(host, schema) {
    const tasks = [];
    const options = {
        ...(await (0, normalize_options_1.normalizeOptions)(host, schema, '@nx/react:remote')),
        // when js is set to true, we want to use the js configuration
        js: schema.js ?? false,
        typescriptConfiguration: schema.js
            ? false
            : schema.typescriptConfiguration ?? true,
        dynamic: schema.dynamic ?? false,
        // TODO(colum): remove when MF works with Crystal
        addPlugin: false,
    };
    if (options.dynamic) {
        // Dynamic remotes generate with library { type: 'var' } by default.
        // We need to ensure that the remote name is a valid variable name.
        const isValidRemote = (0, js_1.isValidVariable)(options.name);
        if (!isValidRemote.isValid) {
            throw new Error(`Invalid remote name provided: ${options.name}. ${isValidRemote.message}`);
        }
    }
    const initAppTask = await (0, application_1.default)(host, {
        ...options,
        // Only webpack works with module federation for now.
        bundler: 'webpack',
        skipFormat: true,
    });
    tasks.push(initAppTask);
    if (schema.host) {
        (0, update_host_with_remote_1.updateHostWithRemote)(host, schema.host, options.projectName);
    }
    // Module federation requires bootstrap code to be dynamically imported.
    // Renaming original entry file so we can use `import(./bootstrap)` in
    // new entry file.
    host.rename((0, path_1.join)(options.appProjectRoot, (0, maybe_js_1.maybeJs)(options, 'src/main.tsx')), (0, path_1.join)(options.appProjectRoot, (0, maybe_js_1.maybeJs)(options, 'src/bootstrap.tsx')));
    addModuleFederationFiles(host, options);
    (0, update_module_federation_project_1.updateModuleFederationProject)(host, options);
    (0, setup_tspath_for_remote_1.setupTspathForRemote)(host, options);
    if (options.ssr) {
        const setupSsrTask = await (0, setup_ssr_1.default)(host, {
            project: options.projectName,
            serverPort: options.devServerPort,
            skipFormat: true,
        });
        tasks.push(setupSsrTask);
        const setupSsrForRemoteTask = await (0, setup_ssr_for_remote_1.setupSsrForRemote)(host, options, options.projectName);
        tasks.push(setupSsrForRemoteTask);
        const projectConfig = (0, devkit_1.readProjectConfiguration)(host, options.projectName);
        projectConfig.targets.server.options.webpackConfig = (0, devkit_1.joinPathFragments)(projectConfig.root, `webpack.server.config.${options.typescriptConfiguration ? 'ts' : 'js'}`);
        (0, devkit_1.updateProjectConfiguration)(host, options.projectName, projectConfig);
    }
    if (!options.setParserOptionsProject) {
        host.delete((0, devkit_1.joinPathFragments)(options.appProjectRoot, 'tsconfig.lint.json'));
    }
    if (options.host && options.dynamic) {
        const hostConfig = (0, devkit_1.readProjectConfiguration)(host, schema.host);
        const pathToMFManifest = (0, devkit_1.joinPathFragments)(hostConfig.sourceRoot, 'assets/module-federation.manifest.json');
        (0, add_remote_to_dynamic_host_1.addRemoteToDynamicHost)(host, options.name, options.devServerPort, pathToMFManifest);
    }
    (0, add_mf_env_to_inputs_1.addMfEnvToTargetDefaultInputs)(host);
    const installTask = (0, devkit_1.addDependenciesToPackageJson)(host, {}, { '@module-federation/enhanced': versions_1.moduleFederationEnhancedVersion });
    tasks.push(installTask);
    if (!options.skipFormat) {
        await (0, devkit_1.formatFiles)(host);
    }
    return (0, devkit_1.runTasksInSerial)(...tasks);
}
exports.default = remoteGenerator;
