"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hookGenerator = hookGenerator;
exports.hookGeneratorInternal = hookGeneratorInternal;
// TODO(jack): Remove inline renderHook function when RTL releases with its own version
const devkit_1 = require("@nx/devkit");
const ast_utils_1 = require("../../utils/ast-utils");
const ensure_typescript_1 = require("@nx/js/src/utils/typescript/ensure-typescript");
const path_1 = require("path");
const artifact_name_and_directory_utils_1 = require("@nx/devkit/src/generators/artifact-name-and-directory-utils");
async function hookGenerator(host, schema) {
    return hookGeneratorInternal(host, {
        nameAndDirectoryFormat: 'derived',
        ...schema,
    });
}
async function hookGeneratorInternal(host, schema) {
    const options = await normalizeOptions(host, schema);
    createFiles(host, options);
    addExportsToBarrel(host, options);
    return await (0, devkit_1.formatFiles)(host);
}
function createFiles(host, options) {
    (0, devkit_1.generateFiles)(host, (0, path_1.join)(__dirname, './files'), options.directory, {
        ...options,
        tmpl: '',
    });
    for (const c of host.listChanges()) {
        let deleteFile = false;
        if (options.skipTests && /.*spec.ts/.test(c.path)) {
            deleteFile = true;
        }
        if (deleteFile) {
            host.delete(c.path);
        }
    }
    if (options.js) {
        (0, devkit_1.toJS)(host);
    }
}
let tsModule;
function addExportsToBarrel(host, options) {
    if (!tsModule) {
        tsModule = (0, ensure_typescript_1.ensureTypescript)();
    }
    const workspace = (0, devkit_1.getProjects)(host);
    const isApp = workspace.get(options.projectName).projectType === 'application';
    if (options.export && !isApp) {
        const indexFilePath = (0, devkit_1.joinPathFragments)(options.projectSourceRoot, options.js ? 'index.js' : 'index.ts');
        const indexSource = host.read(indexFilePath, 'utf-8');
        if (indexSource !== null) {
            const indexSourceFile = tsModule.createSourceFile(indexFilePath, indexSource, tsModule.ScriptTarget.Latest, true);
            const changes = (0, devkit_1.applyChangesToString)(indexSource, (0, ast_utils_1.addImport)(indexSourceFile, `export * from './${options.directory}/${options.fileName}';`));
            host.write(indexFilePath, changes);
        }
    }
}
async function normalizeOptions(host, options) {
    assertValidOptions(options);
    const { artifactName: name, directory: _directory, fileName: _fileName, nameAndDirectoryFormat, project: projectName, } = await (0, artifact_name_and_directory_utils_1.determineArtifactNameAndDirectoryOptions)(host, {
        artifactType: 'hook',
        callingGenerator: '@nx/react:hook',
        name: options.name,
        directory: options.directory,
        derivedDirectory: options.directory,
        flat: options.flat,
        nameAndDirectoryFormat: options.nameAndDirectoryFormat,
        project: options.project,
        fileExtension: 'tsx',
        pascalCaseFile: options.pascalCaseFiles,
        pascalCaseDirectory: options.pascalCaseDirectory,
    });
    let base = _fileName;
    if (base.startsWith('use-')) {
        base = base.substring(4);
    }
    else if (base.startsWith('use')) {
        base = base.substring(3);
    }
    const { className, fileName } = (0, devkit_1.names)(base);
    // If using `as-provided` file and directory, then don't normalize.
    // Otherwise, support legacy behavior of prefixing filename with `use-`.
    const hookFilename = nameAndDirectoryFormat === 'as-provided'
        ? fileName
        : options.pascalCaseFiles
            ? 'use'.concat(className)
            : 'use-'.concat(fileName);
    const hookName = 'use'.concat(className);
    const hookTypeName = 'Use'.concat(className);
    const project = (0, devkit_1.getProjects)(host).get(projectName);
    const { sourceRoot: projectSourceRoot, projectType } = project;
    if (options.export && projectType === 'application') {
        devkit_1.logger.warn(`The "--export" option should not be used with applications and will do nothing.`);
    }
    // Support legacy behavior of derived directory to prefix with `use-`.
    let directory = _directory;
    if (nameAndDirectoryFormat === 'derived') {
        const parts = directory.split('/');
        parts.pop();
        if (!options.flat) {
            parts.push(options.pascalCaseDirectory
                ? 'use'.concat(className)
                : 'use-'.concat(fileName));
        }
        directory = parts.join('/');
    }
    return {
        ...options,
        directory,
        hookName,
        hookTypeName,
        fileName: hookFilename,
        projectSourceRoot,
        projectName,
    };
}
function assertValidOptions(options) {
    const slashes = ['/', '\\'];
    slashes.forEach((s) => {
        if (options.name.indexOf(s) !== -1) {
            const [name, ...rest] = options.name.split(s).reverse();
            let suggestion = rest.map((x) => x.toLowerCase()).join(s);
            if (options.directory) {
                suggestion = `${options.directory}${s}${suggestion}`;
            }
            throw new Error(`Found "${s}" in the hook name. Did you mean to use the --directory option (e.g. \`nx g c ${name} --directory ${suggestion}\`)?`);
        }
    });
}
exports.default = hookGenerator;
