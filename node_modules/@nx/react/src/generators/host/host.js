"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hostGenerator = hostGenerator;
exports.hostGeneratorInternal = hostGeneratorInternal;
const devkit_1 = require("@nx/devkit");
const update_module_federation_project_1 = require("../../rules/update-module-federation-project");
const application_1 = require("../application/application");
const normalize_options_1 = require("../application/lib/normalize-options");
const remote_1 = require("../remote/remote");
const setup_ssr_1 = require("../setup-ssr/setup-ssr");
const add_module_federation_files_1 = require("./lib/add-module-federation-files");
const normalize_remote_1 = require("./lib/normalize-remote");
const setup_ssr_for_host_1 = require("./lib/setup-ssr-for-host");
const update_module_federation_e2e_project_1 = require("./lib/update-module-federation-e2e-project");
const add_mf_env_to_inputs_1 = require("../../utils/add-mf-env-to-inputs");
const js_1 = require("@nx/js");
const versions_1 = require("../../utils/versions");
async function hostGenerator(host, schema) {
    return hostGeneratorInternal(host, {
        projectNameAndRootFormat: 'derived',
        ...schema,
    });
}
async function hostGeneratorInternal(host, schema) {
    const tasks = [];
    const options = {
        ...(await (0, normalize_options_1.normalizeOptions)(host, schema, '@nx/react:host')),
        js: schema.js ?? false,
        typescriptConfiguration: schema.js
            ? false
            : schema.typescriptConfiguration ?? true,
        dynamic: schema.dynamic ?? false,
        // TODO(colum): remove when MF works with Crystal
        addPlugin: false,
    };
    // Check to see if remotes are provided and also check if --dynamic is provided
    // if both are check that the remotes are valid names else throw an error.
    if (options.dynamic && options.remotes?.length > 0) {
        options.remotes.forEach((remote) => {
            const isValidRemote = (0, js_1.isValidVariable)(remote);
            if (!isValidRemote.isValid) {
                throw new Error(`Invalid remote name provided: ${remote}. ${isValidRemote.message}`);
            }
        });
    }
    const initTask = await (0, application_1.default)(host, {
        ...options,
        // The target use-case is loading remotes as child routes, thus always enable routing.
        routing: true,
        // Only webpack works with module federation for now.
        bundler: 'webpack',
        skipFormat: true,
    });
    tasks.push(initTask);
    const remotesWithPorts = [];
    if (schema.remotes) {
        let remotePort = options.devServerPort + 1;
        for (const remote of schema.remotes) {
            const remoteName = await (0, normalize_remote_1.normalizeRemoteName)(host, remote, options);
            remotesWithPorts.push({ name: remoteName, port: remotePort });
            const remoteTask = await (0, remote_1.default)(host, {
                name: remote,
                directory: (0, normalize_remote_1.normalizeRemoteDirectory)(remote, options),
                style: options.style,
                unitTestRunner: options.unitTestRunner,
                e2eTestRunner: options.e2eTestRunner,
                linter: options.linter,
                devServerPort: remotePort,
                ssr: options.ssr,
                skipFormat: true,
                projectNameAndRootFormat: options.projectNameAndRootFormat,
                typescriptConfiguration: options.typescriptConfiguration,
                js: options.js,
                dynamic: options.dynamic,
                host: options.name,
                skipPackageJson: options.skipPackageJson,
            });
            tasks.push(remoteTask);
            remotePort++;
        }
    }
    (0, add_module_federation_files_1.addModuleFederationFiles)(host, options, remotesWithPorts);
    (0, update_module_federation_project_1.updateModuleFederationProject)(host, options);
    (0, update_module_federation_e2e_project_1.updateModuleFederationE2eProject)(host, options);
    if (options.ssr) {
        const setupSsrTask = await (0, setup_ssr_1.default)(host, {
            project: options.projectName,
            serverPort: options.devServerPort,
            skipFormat: true,
        });
        tasks.push(setupSsrTask);
        const setupSsrForHostTask = await (0, setup_ssr_for_host_1.setupSsrForHost)(host, options, options.projectName, remotesWithPorts);
        tasks.push(setupSsrForHostTask);
        const projectConfig = (0, devkit_1.readProjectConfiguration)(host, options.projectName);
        projectConfig.targets.server.options.webpackConfig = (0, devkit_1.joinPathFragments)(projectConfig.root, `webpack.server.config.${options.typescriptConfiguration ? 'ts' : 'js'}`);
        (0, devkit_1.updateProjectConfiguration)(host, options.projectName, projectConfig);
    }
    if (!options.setParserOptionsProject) {
        host.delete((0, devkit_1.joinPathFragments)(options.appProjectRoot, 'tsconfig.lint.json'));
    }
    (0, add_mf_env_to_inputs_1.addMfEnvToTargetDefaultInputs)(host);
    const installTask = (0, devkit_1.addDependenciesToPackageJson)(host, {}, { '@module-federation/enhanced': versions_1.moduleFederationEnhancedVersion });
    tasks.push(installTask);
    if (!options.skipFormat) {
        await (0, devkit_1.formatFiles)(host);
    }
    return (0, devkit_1.runTasksInSerial)(...tasks);
}
exports.default = hostGenerator;
