"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.federateModuleGenerator = federateModuleGenerator;
const devkit_1 = require("@nx/devkit");
const remote_1 = require("../remote/remote");
const utils_1 = require("./lib/utils");
const project_name_and_root_utils_1 = require("@nx/devkit/src/generators/project-name-and-root-utils");
const js_1 = require("@nx/js");
async function federateModuleGenerator(tree, schema) {
    // Check if the file exists
    if (!tree.exists(schema.path)) {
        throw new Error((0, devkit_1.stripIndents) `The "path" provided  does not exist. Please verify the path is correct and pointing to a file that exists in the workspace.
    
    Path: ${schema.path}`);
    }
    const tasks = [];
    // Check remote exists
    const remote = (0, utils_1.checkRemoteExists)(tree, schema.remote);
    let projectRoot, remoteName;
    if (!remote) {
        // create remote
        const remoteGenerator = await (0, remote_1.remoteGeneratorInternal)(tree, {
            name: schema.remote,
            directory: schema.remoteDirectory,
            e2eTestRunner: schema.e2eTestRunner,
            skipFormat: schema.skipFormat,
            linter: schema.linter,
            style: schema.style,
            unitTestRunner: schema.unitTestRunner,
            host: schema.host,
            projectNameAndRootFormat: schema.projectNameAndRootFormat ?? 'derived',
        });
        tasks.push(remoteGenerator);
        const { projectName, projectRoot: remoteRoot } = await (0, project_name_and_root_utils_1.determineProjectNameAndRootOptions)(tree, {
            name: schema.remote,
            directory: schema.remoteDirectory,
            projectType: 'application',
            projectNameAndRootFormat: schema.projectNameAndRootFormat ?? 'derived',
            callingGenerator: '@nx/react:federate-module',
        });
        projectRoot = remoteRoot;
        remoteName = projectName;
    }
    else {
        projectRoot = remote.root;
        remoteName = remote.name;
    }
    // add path to exposes property
    (0, utils_1.addPathToExposes)(tree, projectRoot, schema.name, schema.path);
    // Add new path to tsconfig
    const rootJSON = (0, devkit_1.readJson)(tree, (0, js_1.getRootTsConfigPathInTree)(tree));
    if (!rootJSON?.compilerOptions?.paths[`${remoteName}/${schema.name}`]) {
        (0, js_1.addTsConfigPath)(tree, `${remoteName}/${schema.name}`, [schema.path]);
    }
    if (!schema.skipFormat) {
        await (0, devkit_1.formatFiles)(tree);
    }
    devkit_1.logger.info(`✅️ Updated module federation config.
    Now you can use the module from your host app like this:

    Static import:
    import { MyComponent } from '${remoteName}/${schema.name}';
    
    Dynamic import:
    import('${remoteName}/${schema.name}').then((m) => m.${schema.name});
  `);
    return (0, devkit_1.runTasksInSerial)(...tasks);
}
exports.default = federateModuleGenerator;
