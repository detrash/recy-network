"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.applicationGenerator = applicationGenerator;
exports.applicationGeneratorInternal = applicationGeneratorInternal;
const devkit_1 = require("@nx/devkit");
const project_name_and_root_utils_1 = require("@nx/devkit/src/generators/project-name-and-root-utils");
const js_1 = require("@nx/js");
const versions_1 = require("@nx/js/src/utils/versions");
const path_1 = require("path");
const versions_2 = require("../../utils/versions");
const init_1 = require("../init/init");
const get_npm_scope_1 = require("@nx/js/src/utils/package-json/get-npm-scope");
const has_webpack_plugin_1 = require("../../utils/has-webpack-plugin");
const target_defaults_utils_1 = require("@nx/devkit/src/generators/target-defaults-utils");
const log_show_project_command_1 = require("@nx/devkit/src/utils/log-show-project-command");
const static_serve_configuration_1 = require("../static-serve/static-serve-configuration");
const find_plugin_for_config_file_1 = require("@nx/devkit/src/utils/find-plugin-for-config-file");
function createApplicationFiles(tree, options) {
    if (options.bundler === 'vite') {
        (0, devkit_1.generateFiles)(tree, (0, path_1.join)(__dirname, './files/app-vite'), options.appProjectRoot, {
            ...options,
            ...(0, devkit_1.names)(options.name),
            tmpl: '',
            offsetFromRoot: (0, devkit_1.offsetFromRoot)(options.appProjectRoot),
            rootTsConfigPath: (0, js_1.getRelativePathToRootTsConfig)(tree, options.appProjectRoot),
        });
    }
    else {
        (0, devkit_1.generateFiles)(tree, (0, path_1.join)(__dirname, './files/app-webpack'), options.appProjectRoot, {
            ...options,
            ...(0, devkit_1.names)(options.name),
            tmpl: '',
            offsetFromRoot: (0, devkit_1.offsetFromRoot)(options.appProjectRoot),
            rootTsConfigPath: (0, js_1.getRelativePathToRootTsConfig)(tree, options.appProjectRoot),
            webpackPluginOptions: (0, has_webpack_plugin_1.hasWebpackPlugin)(tree)
                ? {
                    compiler: options.compiler,
                    target: 'web',
                    outputPath: (0, devkit_1.joinPathFragments)('dist', options.appProjectRoot != '.'
                        ? options.appProjectRoot
                        : options.projectName),
                    tsConfig: './tsconfig.app.json',
                    main: './src/main.ts',
                    assets: ['./src/favicon.ico', './src/assets'],
                    index: './src/index.html',
                    baseHref: '/',
                    styles: [`./src/styles.${options.style}`],
                }
                : null,
        });
        if (options.unitTestRunner === 'none') {
            tree.delete((0, path_1.join)(options.appProjectRoot, './src/app/app.element.spec.ts'));
        }
    }
    (0, devkit_1.updateJson)(tree, (0, devkit_1.joinPathFragments)(options.appProjectRoot, 'tsconfig.json'), (json) => {
        return {
            ...json,
            compilerOptions: {
                ...(json.compilerOptions || {}),
                strict: options.strict,
            },
        };
    });
}
async function setupBundler(tree, options) {
    const main = (0, devkit_1.joinPathFragments)(options.appProjectRoot, 'src/main.ts');
    const tsConfig = (0, devkit_1.joinPathFragments)(options.appProjectRoot, 'tsconfig.app.json');
    const assets = [
        (0, devkit_1.joinPathFragments)(options.appProjectRoot, 'src/favicon.ico'),
        (0, devkit_1.joinPathFragments)(options.appProjectRoot, 'src/assets'),
    ];
    if (options.bundler === 'webpack') {
        const { configurationGenerator } = (0, devkit_1.ensurePackage)('@nx/webpack', versions_2.nxVersion);
        await configurationGenerator(tree, {
            target: 'web',
            project: options.projectName,
            main,
            tsConfig,
            compiler: options.compiler ?? 'babel',
            devServer: true,
            webpackConfig: (0, devkit_1.joinPathFragments)(options.appProjectRoot, 'webpack.config.js'),
            skipFormat: true,
            addPlugin: options.addPlugin,
        });
        const project = (0, devkit_1.readProjectConfiguration)(tree, options.projectName);
        if (project.targets.build) {
            const prodConfig = project.targets.build.configurations.production;
            const buildOptions = project.targets.build.options;
            buildOptions.assets = assets;
            buildOptions.index = (0, devkit_1.joinPathFragments)(options.appProjectRoot, 'src/index.html');
            buildOptions.baseHref = '/';
            buildOptions.styles = [
                (0, devkit_1.joinPathFragments)(options.appProjectRoot, `src/styles.${options.style}`),
            ];
            // We can delete that, because this projest is an application
            // and applications have a .babelrc file in their root dir.
            // So Nx will find it and use it
            delete buildOptions.babelUpwardRootMode;
            buildOptions.scripts = [];
            prodConfig.fileReplacements = [
                {
                    replace: (0, devkit_1.joinPathFragments)(options.appProjectRoot, `src/environments/environment.ts`),
                    with: (0, devkit_1.joinPathFragments)(options.appProjectRoot, `src/environments/environment.prod.ts`),
                },
            ];
            prodConfig.optimization = true;
            prodConfig.outputHashing = 'all';
            prodConfig.sourceMap = false;
            prodConfig.namedChunks = false;
            prodConfig.extractLicenses = true;
            prodConfig.vendorChunk = false;
            (0, devkit_1.updateProjectConfiguration)(tree, options.projectName, project);
        }
        // TODO(jack): Flush this out... no bundler should be possible for web but the experience isn't holistic due to missing features (e.g. writing index.html).
    }
    else if (options.bundler === 'none') {
        const project = (0, devkit_1.readProjectConfiguration)(tree, options.projectName);
        (0, target_defaults_utils_1.addBuildTargetDefaults)(tree, `@nx/js:${options.compiler}`);
        project.targets.build = {
            executor: `@nx/js:${options.compiler}`,
            outputs: ['{options.outputPath}'],
            options: {
                main,
                outputPath: (0, devkit_1.joinPathFragments)('dist', options.appProjectRoot),
                tsConfig,
            },
        };
        (0, devkit_1.updateProjectConfiguration)(tree, options.projectName, project);
    }
    else {
        throw new Error('Unsupported bundler type');
    }
}
async function addProject(tree, options) {
    const targets = {};
    (0, devkit_1.addProjectConfiguration)(tree, options.projectName, {
        projectType: 'application',
        root: options.appProjectRoot,
        sourceRoot: (0, devkit_1.joinPathFragments)(options.appProjectRoot, 'src'),
        tags: options.parsedTags,
        targets,
    }, options.standaloneConfig);
}
function setDefaults(tree, options) {
    const nxJson = (0, devkit_1.readNxJson)(tree);
    nxJson.generators = nxJson.generators || {};
    nxJson.generators['@nx/web:application'] = {
        style: options.style,
        linter: options.linter,
        unitTestRunner: options.unitTestRunner,
        e2eTestRunner: options.e2eTestRunner,
        ...nxJson.generators['@nx/web:application'],
    };
    (0, devkit_1.updateNxJson)(tree, nxJson);
}
async function applicationGenerator(host, schema) {
    return await applicationGeneratorInternal(host, {
        addPlugin: false,
        projectNameAndRootFormat: 'derived',
        ...schema,
    });
}
async function applicationGeneratorInternal(host, schema) {
    const options = await normalizeOptions(host, schema);
    const tasks = [];
    const jsInitTask = await (0, js_1.initGenerator)(host, {
        js: false,
        skipFormat: true,
    });
    tasks.push(jsInitTask);
    const webTask = await (0, init_1.webInitGenerator)(host, {
        ...options,
        skipFormat: true,
    });
    tasks.push(webTask);
    await addProject(host, options);
    if (options.bundler !== 'vite') {
        await setupBundler(host, options);
    }
    createApplicationFiles(host, options);
    if (options.bundler === 'vite') {
        const { viteConfigurationGenerator, createOrEditViteConfig } = (0, devkit_1.ensurePackage)('@nx/vite', versions_2.nxVersion);
        // We recommend users use `import.meta.env.MODE` and other variables in their code to differentiate between production and development.
        // See: https://vitejs.dev/guide/env-and-mode.html
        if (host.exists((0, devkit_1.joinPathFragments)(options.appProjectRoot, 'src/environments'))) {
            host.delete((0, devkit_1.joinPathFragments)(options.appProjectRoot, 'src/environments'));
        }
        const viteTask = await viteConfigurationGenerator(host, {
            uiFramework: 'none',
            project: options.projectName,
            newProject: true,
            includeVitest: options.unitTestRunner === 'vitest',
            inSourceTests: options.inSourceTests,
            skipFormat: true,
            addPlugin: options.addPlugin,
        });
        tasks.push(viteTask);
        createOrEditViteConfig(host, {
            project: options.projectName,
            includeLib: false,
            includeVitest: options.unitTestRunner === 'vitest',
            inSourceTests: options.inSourceTests,
        }, false);
    }
    if (options.bundler !== 'vite' && options.unitTestRunner === 'vitest') {
        const { vitestGenerator, createOrEditViteConfig } = (0, devkit_1.ensurePackage)('@nx/vite', versions_2.nxVersion);
        const vitestTask = await vitestGenerator(host, {
            uiFramework: 'none',
            project: options.projectName,
            coverageProvider: 'v8',
            inSourceTests: options.inSourceTests,
            skipFormat: true,
            addPlugin: options.addPlugin,
        });
        tasks.push(vitestTask);
        createOrEditViteConfig(host, {
            project: options.projectName,
            includeLib: false,
            includeVitest: true,
            inSourceTests: options.inSourceTests,
        }, true);
    }
    if ((options.bundler === 'vite' || options.unitTestRunner === 'vitest') &&
        options.inSourceTests) {
        host.delete((0, devkit_1.joinPathFragments)(options.appProjectRoot, `src/app/app.element.spec.ts`));
    }
    if (options.linter === 'eslint') {
        const { lintProjectGenerator } = (0, devkit_1.ensurePackage)('@nx/eslint', versions_2.nxVersion);
        const lintTask = await lintProjectGenerator(host, {
            linter: options.linter,
            project: options.projectName,
            tsConfigPaths: [
                (0, devkit_1.joinPathFragments)(options.appProjectRoot, 'tsconfig.app.json'),
            ],
            unitTestRunner: options.unitTestRunner,
            skipFormat: true,
            setParserOptionsProject: options.setParserOptionsProject,
            addPlugin: options.addPlugin,
        });
        tasks.push(lintTask);
    }
    const nxJson = (0, devkit_1.readNxJson)(host);
    let hasPlugin;
    let buildPlugin;
    let buildConfigFile;
    if (options.bundler === 'webpack' || options.bundler === 'vite') {
        buildPlugin = `@nx/${options.bundler}/plugin`;
        buildConfigFile =
            options.bundler === 'webpack' ? 'webpack.config.js' : `vite.config.ts`;
        hasPlugin = nxJson.plugins?.find((p) => typeof p === 'string' ? p === buildPlugin : p.plugin === buildPlugin);
    }
    if (!hasPlugin) {
        await (0, static_serve_configuration_1.default)(host, {
            buildTarget: `${options.projectName}:build`,
            spa: true,
        });
    }
    if (options.e2eTestRunner === 'cypress') {
        const { configurationGenerator } = (0, devkit_1.ensurePackage)('@nx/cypress', versions_2.nxVersion);
        (0, devkit_1.addProjectConfiguration)(host, options.e2eProjectName, {
            root: options.e2eProjectRoot,
            sourceRoot: (0, devkit_1.joinPathFragments)(options.e2eProjectRoot, 'src'),
            projectType: 'application',
            targets: {},
            tags: [],
            implicitDependencies: [options.projectName],
        });
        const cypressTask = await configurationGenerator(host, {
            ...options,
            project: options.e2eProjectName,
            devServerTarget: `${options.projectName}:${options.e2eWebServerTarget}`,
            baseUrl: options.e2eWebServerAddress,
            directory: 'src',
            skipFormat: true,
            webServerCommands: hasPlugin
                ? {
                    default: `nx run ${options.projectName}:${options.e2eWebServerTarget}`,
                    production: `nx run ${options.projectName}:preview`,
                }
                : undefined,
            ciWebServerCommand: hasPlugin
                ? `nx run ${options.projectName}:${options.e2eCiWebServerTarget}`
                : undefined,
            ciBaseUrl: options.bundler === 'vite' ? options.e2eCiBaseUrl : undefined,
        });
        if (options.addPlugin ||
            (0, devkit_1.readNxJson)(host).plugins?.find((p) => typeof p === 'string'
                ? p === '@nx/cypress/plugin'
                : p.plugin === '@nx/cypress/plugin')) {
            let buildTarget = '^build';
            if (hasPlugin) {
                const matchingPlugin = await (0, find_plugin_for_config_file_1.findPluginForConfigFile)(host, buildPlugin, (0, devkit_1.joinPathFragments)(options.appProjectRoot, buildConfigFile));
                if (matchingPlugin && typeof matchingPlugin !== 'string') {
                    buildTarget = `^${matchingPlugin.options?.buildTargetName ?? 'build'}`;
                }
            }
            await (0, target_defaults_utils_1.addE2eCiTargetDefaults)(host, '@nx/cypress/plugin', buildTarget, (0, devkit_1.joinPathFragments)(options.e2eProjectRoot, `cypress.config.ts`));
        }
        tasks.push(cypressTask);
    }
    else if (options.e2eTestRunner === 'playwright') {
        const { configurationGenerator: playwrightConfigGenerator } = (0, devkit_1.ensurePackage)('@nx/playwright', versions_2.nxVersion);
        (0, devkit_1.addProjectConfiguration)(host, options.e2eProjectName, {
            root: options.e2eProjectRoot,
            sourceRoot: (0, devkit_1.joinPathFragments)(options.e2eProjectRoot, 'src'),
            projectType: 'application',
            targets: {},
            tags: [],
            implicitDependencies: [options.projectName],
        });
        const playwrightTask = await playwrightConfigGenerator(host, {
            project: options.e2eProjectName,
            skipFormat: true,
            skipPackageJson: false,
            directory: 'src',
            js: false,
            linter: options.linter,
            setParserOptionsProject: options.setParserOptionsProject,
            webServerCommand: `${(0, devkit_1.getPackageManagerCommand)().exec} nx run ${options.projectName}:${options.e2eCiWebServerTarget}`,
            webServerAddress: options.e2eCiBaseUrl,
            addPlugin: options.addPlugin,
        });
        if (options.addPlugin ||
            (0, devkit_1.readNxJson)(host).plugins?.find((p) => typeof p === 'string'
                ? p === '@nx/playwright/plugin'
                : p.plugin === '@nx/playwright/plugin')) {
            let buildTarget = '^build';
            if (hasPlugin) {
                const matchingPlugin = await (0, find_plugin_for_config_file_1.findPluginForConfigFile)(host, buildPlugin, (0, devkit_1.joinPathFragments)(options.appProjectRoot, buildConfigFile));
                if (matchingPlugin && typeof matchingPlugin !== 'string') {
                    buildTarget = `^${matchingPlugin.options?.buildTargetName ?? 'build'}`;
                }
            }
            await (0, target_defaults_utils_1.addE2eCiTargetDefaults)(host, '@nx/playwright/plugin', buildTarget, (0, devkit_1.joinPathFragments)(options.e2eProjectRoot, `playwright.config.ts`));
        }
        tasks.push(playwrightTask);
    }
    if (options.unitTestRunner === 'jest') {
        const { configurationGenerator } = (0, devkit_1.ensurePackage)('@nx/jest', versions_2.nxVersion);
        const jestTask = await configurationGenerator(host, {
            project: options.projectName,
            skipSerializers: true,
            setupFile: 'web-components',
            compiler: options.compiler,
            skipFormat: true,
            addPlugin: options.addPlugin,
        });
        tasks.push(jestTask);
    }
    if (options.compiler === 'swc') {
        (0, devkit_1.writeJson)(host, (0, devkit_1.joinPathFragments)(options.appProjectRoot, '.swcrc'), {
            jsc: {
                parser: {
                    syntax: 'typescript',
                },
                target: 'es2016',
            },
        });
        const installTask = (0, devkit_1.addDependenciesToPackageJson)(host, {}, { '@swc/core': versions_1.swcCoreVersion, 'swc-loader': versions_2.swcLoaderVersion });
        tasks.push(installTask);
    }
    else {
        (0, devkit_1.writeJson)(host, (0, devkit_1.joinPathFragments)(options.appProjectRoot, '.babelrc'), {
            presets: ['@nx/js/babel'],
        });
    }
    setDefaults(host, options);
    tasks.push((0, devkit_1.addDependenciesToPackageJson)(host, { tslib: versions_2.tsLibVersion }, { '@types/node': versions_2.typesNodeVersion }));
    if (!schema.skipFormat) {
        await (0, devkit_1.formatFiles)(host);
    }
    tasks.push(() => {
        (0, log_show_project_command_1.logShowProjectCommand)(options.projectName);
    });
    return (0, devkit_1.runTasksInSerial)(...tasks);
}
async function normalizeOptions(host, options) {
    const { projectName: appProjectName, projectRoot: appProjectRoot, projectNameAndRootFormat, } = await (0, project_name_and_root_utils_1.determineProjectNameAndRootOptions)(host, {
        name: options.name,
        projectType: 'application',
        directory: options.directory,
        projectNameAndRootFormat: options.projectNameAndRootFormat,
        callingGenerator: '@nx/web:application',
    });
    options.projectNameAndRootFormat = projectNameAndRootFormat;
    const nxJson = (0, devkit_1.readNxJson)(host);
    const addPluginDefault = process.env.NX_ADD_PLUGINS !== 'false' &&
        nxJson.useInferencePlugins !== false;
    options.addPlugin ??= addPluginDefault;
    let e2ePort = 4200;
    let e2eWebServerTarget = 'serve';
    let e2eCiWebServerTarget = options.bundler === 'vite' ? 'preview' : 'serve-static';
    if (options.addPlugin) {
        if (nxJson.plugins) {
            for (const plugin of nxJson.plugins) {
                if (options.bundler === 'vite' &&
                    typeof plugin === 'object' &&
                    plugin.plugin === '@nx/vite/plugin') {
                    e2eCiWebServerTarget =
                        plugin.options?.previewTargetName ??
                            e2eCiWebServerTarget;
                    e2eWebServerTarget =
                        plugin.options?.serveTargetName ??
                            e2eWebServerTarget;
                }
                else if (options.bundler === 'webpack' &&
                    typeof plugin === 'object' &&
                    plugin.plugin === '@nx/webpack/plugin') {
                    e2eCiWebServerTarget =
                        plugin.options?.serveStaticTargetName ??
                            e2eCiWebServerTarget;
                    e2eWebServerTarget =
                        plugin.options?.serveTargetName ??
                            e2eWebServerTarget;
                }
            }
        }
    }
    if (nxJson.targetDefaults?.[e2eWebServerTarget] &&
        nxJson.targetDefaults?.[e2eWebServerTarget].options?.port) {
        e2ePort = nxJson.targetDefaults?.[e2eWebServerTarget].options?.port;
    }
    const e2eProjectName = `${appProjectName}-e2e`;
    const e2eProjectRoot = `${appProjectRoot}-e2e`;
    const e2eWebServerAddress = `http://localhost:${e2ePort}`;
    const e2eCiBaseUrl = options.bundler === 'vite'
        ? 'http://localhost:4300'
        : `http://localhost:${e2ePort}`;
    const npmScope = (0, get_npm_scope_1.getNpmScope)(host);
    const parsedTags = options.tags
        ? options.tags.split(',').map((s) => s.trim())
        : [];
    options.style = options.style || 'css';
    options.linter = options.linter || 'eslint';
    options.unitTestRunner = options.unitTestRunner || 'jest';
    options.e2eTestRunner = options.e2eTestRunner || 'playwright';
    return {
        ...options,
        prefix: options.prefix ?? npmScope ?? 'app',
        name: (0, devkit_1.names)(options.name).fileName,
        compiler: options.compiler ?? 'babel',
        bundler: options.bundler ?? 'webpack',
        projectName: appProjectName,
        strict: options.strict ?? true,
        appProjectRoot,
        e2eProjectRoot,
        e2eProjectName,
        e2eWebServerAddress,
        e2eWebServerTarget,
        e2eCiWebServerTarget,
        e2eCiBaseUrl,
        e2ePort,
        parsedTags,
    };
}
exports.default = applicationGenerator;
