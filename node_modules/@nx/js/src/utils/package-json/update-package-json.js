"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.updatePackageJson = updatePackageJson;
exports.getExports = getExports;
exports.getUpdatedPackageJsonContent = getUpdatedPackageJsonContent;
// eslint-disable-next-line @typescript-eslint/no-restricted-imports
const lock_file_1 = require("nx/src/plugins/js/lock-file/lock-file");
// eslint-disable-next-line @typescript-eslint/no-restricted-imports
const create_package_json_1 = require("nx/src/plugins/js/package-json/create-package-json");
const devkit_1 = require("@nx/devkit");
const path_1 = require("path");
const fs_extra_1 = require("fs-extra");
const fileutils_1 = require("nx/src/utils/fileutils");
const fs_1 = require("fs");
const nx_deps_cache_1 = require("nx/src/project-graph/nx-deps-cache");
const get_main_file_dir_1 = require("../get-main-file-dir");
function updatePackageJson(options, context, target, dependencies, fileMap = null) {
    let packageJson;
    if (fileMap == null) {
        fileMap = (0, nx_deps_cache_1.readFileMapCache)()?.fileMap?.projectFileMap || {};
    }
    if (options.updateBuildableProjectDepsInPackageJson) {
        packageJson = (0, create_package_json_1.createPackageJson)(context.projectName, context.projectGraph, {
            target: context.targetName,
            root: context.root,
            // By default we remove devDependencies since this is a production build.
            isProduction: true,
        }, fileMap);
        if (options.excludeLibsInPackageJson) {
            dependencies = dependencies.filter((dep) => dep.node.type !== 'lib');
        }
        addMissingDependencies(packageJson, context, dependencies, options.buildableProjectDepsInPackageJsonType);
    }
    else {
        const pathToPackageJson = (0, path_1.join)(context.root, options.projectRoot, 'package.json');
        packageJson = (0, fileutils_1.fileExists)(pathToPackageJson)
            ? (0, devkit_1.readJsonFile)(pathToPackageJson)
            : { name: context.projectName, version: '0.0.1' };
    }
    if (packageJson.type === 'module') {
        if (options.format?.includes('cjs')) {
            devkit_1.logger.warn(`Package type is set to "module" but "cjs" format is included. Going to use "esm" format instead. You can change the package type to "commonjs" or remove type in the package.json file.`);
        }
        options.format = ['esm'];
    }
    else if (packageJson.type === 'commonjs') {
        if (options.format?.includes('esm')) {
            devkit_1.logger.warn(`Package type is set to "commonjs" but "esm" format is included. Going to use "cjs" format instead. You can change the package type to "module" or remove type in the package.json file.`);
        }
        options.format = ['cjs'];
    }
    // update package specific settings
    packageJson = getUpdatedPackageJsonContent(packageJson, options);
    // save files
    (0, devkit_1.writeJsonFile)(`${options.outputPath}/package.json`, packageJson);
    if (options.generateLockfile) {
        const packageManager = (0, devkit_1.detectPackageManager)(context.root);
        if (packageManager === 'bun') {
            devkit_1.logger.warn(`Bun lockfile generation is unsupported. Remove "generateLockfile" option or set it to false.`);
        }
        else {
            const lockFile = (0, lock_file_1.createLockFile)(packageJson, context.projectGraph, packageManager);
            (0, fs_extra_1.writeFileSync)(`${options.outputPath}/${(0, lock_file_1.getLockFileName)(packageManager)}`, lockFile, {
                encoding: 'utf-8',
            });
        }
    }
}
function isNpmNode(node, graph) {
    return !!(graph.externalNodes[node.name]?.type === 'npm');
}
function isWorkspaceProject(node, graph) {
    return !!graph.nodes[node.name];
}
function addMissingDependencies(packageJson, { projectName, targetName, configurationName, root, projectGraph, }, dependencies, propType = 'dependencies') {
    const workspacePackageJson = (0, devkit_1.readJsonFile)((0, devkit_1.joinPathFragments)(devkit_1.workspaceRoot, 'package.json'));
    dependencies.forEach((entry) => {
        if (isNpmNode(entry.node, projectGraph)) {
            const { packageName, version } = entry.node.data;
            if (packageJson.dependencies?.[packageName] ||
                packageJson.devDependencies?.[packageName] ||
                packageJson.peerDependencies?.[packageName]) {
                return;
            }
            if (workspacePackageJson.devDependencies?.[packageName]) {
                return;
            }
            packageJson[propType] ??= {};
            packageJson[propType][packageName] = version;
        }
        else if (isWorkspaceProject(entry.node, projectGraph)) {
            const packageName = entry.name;
            if (!!workspacePackageJson.devDependencies?.[packageName]) {
                return;
            }
            if (!packageJson.dependencies?.[packageName] &&
                !packageJson.devDependencies?.[packageName] &&
                !packageJson.peerDependencies?.[packageName]) {
                const outputs = (0, devkit_1.getOutputsForTargetAndConfiguration)({
                    project: projectName,
                    target: targetName,
                    configuration: configurationName,
                }, {}, entry.node);
                const depPackageJsonPath = (0, path_1.join)(root, outputs[0], 'package.json');
                if ((0, fs_1.existsSync)(depPackageJsonPath)) {
                    const version = (0, devkit_1.readJsonFile)(depPackageJsonPath).version;
                    packageJson[propType] ??= {};
                    packageJson[propType][packageName] = version;
                }
            }
        }
    });
}
function getExports(options) {
    const mainFile = options.outputFileName
        ? options.outputFileName.replace(/\.[tj]s$/, '')
        : (0, path_1.basename)(options.main).replace(/\.[tj]s$/, '');
    const relativeMainFileDir = options.outputFileName
        ? './'
        : (0, get_main_file_dir_1.getRelativeDirectoryToProjectRoot)(options.main, options.rootDir ?? options.projectRoot);
    const exports = {
        '.': relativeMainFileDir + mainFile + options.fileExt,
    };
    if (options.additionalEntryPoints) {
        const jsRegex = /\.[jt]sx?$/;
        for (const file of options.additionalEntryPoints) {
            const { ext: fileExt, name: fileName } = (0, path_1.parse)(file);
            const relativeDir = (0, get_main_file_dir_1.getRelativeDirectoryToProjectRoot)(file, options.projectRoot);
            const sourceFilePath = relativeDir + fileName;
            const entryRelativeDir = relativeDir.replace(/^\.\/src\//, './');
            const entryFilepath = entryRelativeDir + fileName;
            const isJsFile = jsRegex.test(fileExt);
            if (isJsFile && fileName === 'index') {
                const barrelEntry = entryRelativeDir.replace(/\/$/, '');
                exports[barrelEntry] = sourceFilePath + options.fileExt;
            }
            exports[isJsFile ? entryFilepath : entryFilepath + fileExt] =
                sourceFilePath + (isJsFile ? options.fileExt : fileExt);
        }
    }
    return exports;
}
function getUpdatedPackageJsonContent(packageJson, options) {
    // Default is CJS unless esm is explicitly passed.
    const hasCjsFormat = !options.format || options.format?.includes('cjs');
    const hasEsmFormat = options.format?.includes('esm');
    if (options.generateExportsField) {
        packageJson.exports ??=
            typeof packageJson.exports === 'string' ? {} : { ...packageJson.exports };
        packageJson.exports['./package.json'] ??= './package.json';
    }
    if (hasEsmFormat) {
        const esmExports = getExports({
            ...options,
            fileExt: options.outputFileExtensionForEsm ?? '.js',
        });
        packageJson.module ??= esmExports['.'];
        if (!hasCjsFormat) {
            packageJson.type ??= 'module';
            packageJson.main ??= esmExports['.'];
        }
        if (options.generateExportsField) {
            for (const [exportEntry, filePath] of Object.entries(esmExports)) {
                packageJson.exports[exportEntry] ??= hasCjsFormat
                    ? { import: filePath }
                    : filePath;
            }
        }
    }
    // CJS output may have .cjs or .js file extensions.
    // Bundlers like rollup and esbuild supports .cjs for CJS and .js for ESM.
    // Bundlers/Compilers like webpack, tsc, swc do not have different file extensions (unless you use .mts or .cts in source).
    if (hasCjsFormat) {
        const cjsExports = getExports({
            ...options,
            fileExt: options.outputFileExtensionForCjs ?? '.js',
        });
        packageJson.main ??= cjsExports['.'];
        if (!hasEsmFormat) {
            packageJson.type ??= 'commonjs';
        }
        if (options.generateExportsField) {
            for (const [exportEntry, filePath] of Object.entries(cjsExports)) {
                if (hasEsmFormat) {
                    packageJson.exports[exportEntry]['default'] ??= filePath;
                }
                else {
                    packageJson.exports[exportEntry] ??= filePath;
                }
            }
        }
    }
    if (!options.skipTypings) {
        const mainFile = (0, path_1.basename)(options.main).replace(/\.[tj]s$/, '');
        const relativeMainFileDir = (0, get_main_file_dir_1.getRelativeDirectoryToProjectRoot)(options.main, options.projectRoot);
        const typingsFile = `${relativeMainFileDir}${mainFile}.d.ts`;
        packageJson.types ??= typingsFile;
    }
    return packageJson;
}
