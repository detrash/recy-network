"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.findEslintFile = findEslintFile;
exports.isEslintConfigSupported = isEslintConfigSupported;
exports.updateRelativePathsInConfig = updateRelativePathsInConfig;
exports.addOverrideToLintConfig = addOverrideToLintConfig;
exports.updateOverrideInLintConfig = updateOverrideInLintConfig;
exports.lintConfigHasOverride = lintConfigHasOverride;
exports.replaceOverridesInLintConfig = replaceOverridesInLintConfig;
exports.addExtendsToLintConfig = addExtendsToLintConfig;
exports.addPluginsToLintConfig = addPluginsToLintConfig;
exports.addIgnoresToLintConfig = addIgnoresToLintConfig;
exports.getPluginImport = getPluginImport;
const devkit_1 = require("@nx/devkit");
const flat_config_1 = require("../../utils/flat-config");
const ast_utils_1 = require("./flat-config/ast-utils");
const path_utils_1 = require("./flat-config/path-utils");
const config_file_1 = require("../../utils/config-file");
function findEslintFile(tree, projectRoot) {
    if (projectRoot === undefined && tree.exists(config_file_1.baseEsLintConfigFile)) {
        return config_file_1.baseEsLintConfigFile;
    }
    if (projectRoot === undefined && tree.exists(config_file_1.baseEsLintFlatConfigFile)) {
        return config_file_1.baseEsLintFlatConfigFile;
    }
    projectRoot ??= '';
    for (const file of config_file_1.ESLINT_CONFIG_FILENAMES) {
        if (tree.exists((0, devkit_1.joinPathFragments)(projectRoot, file))) {
            return file;
        }
    }
    return null;
}
function isEslintConfigSupported(tree, projectRoot = '') {
    const eslintFile = findEslintFile(tree, projectRoot);
    if (!eslintFile) {
        return false;
    }
    return eslintFile.endsWith('.json') || eslintFile.endsWith('.config.js');
}
function updateRelativePathsInConfig(tree, sourcePath, destinationPath) {
    if (sourcePath === destinationPath ||
        !isEslintConfigSupported(tree, destinationPath)) {
        return;
    }
    const configPath = (0, devkit_1.joinPathFragments)(destinationPath, findEslintFile(tree, destinationPath));
    const offset = (0, devkit_1.offsetFromRoot)(destinationPath);
    if ((0, flat_config_1.useFlatConfig)(tree)) {
        const config = tree.read(configPath, 'utf-8');
        tree.write(configPath, replaceFlatConfigPaths(config, sourcePath, offset, destinationPath, tree));
    }
    else {
        (0, devkit_1.updateJson)(tree, configPath, (json) => {
            if (typeof json.extends === 'string') {
                json.extends = offsetFilePath(sourcePath, json.extends, offset, tree);
            }
            else if (json.extends) {
                json.extends = json.extends.map((extend) => offsetFilePath(sourcePath, extend, offset, tree));
            }
            json.overrides?.forEach((o) => {
                if (o.parserOptions?.project) {
                    o.parserOptions.project = Array.isArray(o.parserOptions.project)
                        ? o.parserOptions.project.map((p) => p.replace(sourcePath, destinationPath))
                        : o.parserOptions.project.replace(sourcePath, destinationPath);
                }
            });
            return json;
        });
    }
}
function replaceFlatConfigPaths(config, sourceRoot, offset, destinationRoot, tree) {
    let match;
    let newConfig = config;
    // replace requires
    const requireRegex = RegExp(/require\(['"](.*)['"]\)/g);
    while ((match = requireRegex.exec(newConfig)) !== null) {
        const newPath = offsetFilePath(sourceRoot, match[1], offset, tree);
        newConfig =
            newConfig.slice(0, match.index) +
                `require('${newPath}')` +
                newConfig.slice(match.index + match[0].length);
    }
    // replace projects
    const projectRegex = RegExp(/project:\s?\[?['"](.*)['"]\]?/g);
    while ((match = projectRegex.exec(newConfig)) !== null) {
        const newProjectDef = match[0].replaceAll(sourceRoot, destinationRoot);
        newConfig =
            newConfig.slice(0, match.index) +
                newProjectDef +
                newConfig.slice(match.index + match[0].length);
    }
    return newConfig;
}
function offsetFilePath(projectRoot, pathToFile, offset, tree) {
    if (config_file_1.ESLINT_CONFIG_FILENAMES.some((eslintFile) => pathToFile.includes(eslintFile))) {
        // if the file is point to base eslint
        const rootEslint = findEslintFile(tree);
        if (rootEslint) {
            return (0, devkit_1.joinPathFragments)(offset, rootEslint);
        }
    }
    if (!pathToFile.startsWith('..')) {
        // not a relative path
        return pathToFile;
    }
    return (0, devkit_1.joinPathFragments)(offset, projectRoot, pathToFile);
}
function addOverrideToLintConfig(tree, root, override, options = {
    insertAtTheEnd: true,
}) {
    const isBase = options.checkBaseConfig && findEslintFile(tree, root).includes('.base');
    if ((0, flat_config_1.useFlatConfig)(tree)) {
        const fileName = (0, devkit_1.joinPathFragments)(root, isBase ? config_file_1.baseEsLintFlatConfigFile : (0, flat_config_1.flatConfigEslintFilename)(tree));
        const flatOverride = (0, ast_utils_1.generateFlatOverride)(override);
        let content = tree.read(fileName, 'utf8');
        // we will be using compat here so we need to make sure it's added
        if (overrideNeedsCompat(override)) {
            content = (0, ast_utils_1.addCompatToFlatConfig)(content);
        }
        tree.write(fileName, (0, ast_utils_1.addBlockToFlatConfigExport)(content, flatOverride, options));
    }
    else {
        const fileName = (0, devkit_1.joinPathFragments)(root, isBase ? config_file_1.baseEsLintConfigFile : '.eslintrc.json');
        (0, devkit_1.updateJson)(tree, fileName, (json) => {
            json.overrides ??= [];
            if (options.insertAtTheEnd) {
                json.overrides.push(override);
            }
            else {
                json.overrides.unshift(override);
            }
            return json;
        });
    }
}
function overrideNeedsCompat(override) {
    return (override.env || override.extends || override.plugins || override.parser);
}
function updateOverrideInLintConfig(tree, root, lookup, update) {
    if ((0, flat_config_1.useFlatConfig)(tree)) {
        const fileName = (0, devkit_1.joinPathFragments)(root, (0, flat_config_1.flatConfigEslintFilename)(tree));
        let content = tree.read(fileName, 'utf8');
        content = (0, ast_utils_1.replaceOverride)(content, root, lookup, update);
        tree.write(fileName, content);
    }
    else {
        const fileName = (0, devkit_1.joinPathFragments)(root, '.eslintrc.json');
        if (!tree.exists(fileName)) {
            return;
        }
        const existingJson = (0, devkit_1.readJson)(tree, fileName);
        if (!existingJson.overrides || !existingJson.overrides.some(lookup)) {
            return;
        }
        (0, devkit_1.updateJson)(tree, fileName, (json) => {
            const index = json.overrides.findIndex(lookup);
            if (index !== -1) {
                const newOverride = update(json.overrides[index]);
                if (newOverride) {
                    json.overrides[index] = newOverride;
                }
                else {
                    json.overrides.splice(index, 1);
                }
            }
            return json;
        });
    }
}
function lintConfigHasOverride(tree, root, lookup, checkBaseConfig = false) {
    if (!isEslintConfigSupported(tree, root)) {
        return false;
    }
    const isBase = checkBaseConfig && findEslintFile(tree, root).includes('.base');
    if ((0, flat_config_1.useFlatConfig)(tree)) {
        const fileName = (0, devkit_1.joinPathFragments)(root, isBase ? config_file_1.baseEsLintFlatConfigFile : (0, flat_config_1.flatConfigEslintFilename)(tree));
        const content = tree.read(fileName, 'utf8');
        return (0, ast_utils_1.hasOverride)(content, lookup);
    }
    else {
        const fileName = (0, devkit_1.joinPathFragments)(root, isBase ? config_file_1.baseEsLintConfigFile : '.eslintrc.json');
        return (0, devkit_1.readJson)(tree, fileName).overrides?.some(lookup) || false;
    }
}
function replaceOverridesInLintConfig(tree, root, overrides) {
    if ((0, flat_config_1.useFlatConfig)(tree)) {
        const fileName = (0, devkit_1.joinPathFragments)(root, (0, flat_config_1.flatConfigEslintFilename)(tree));
        let content = tree.read(fileName, 'utf8');
        // we will be using compat here so we need to make sure it's added
        if (overrides.some(overrideNeedsCompat)) {
            content = (0, ast_utils_1.addCompatToFlatConfig)(content);
        }
        content = (0, ast_utils_1.removeOverridesFromLintConfig)(content);
        overrides.forEach((override) => {
            const flatOverride = (0, ast_utils_1.generateFlatOverride)(override);
            content = (0, ast_utils_1.addBlockToFlatConfigExport)(content, flatOverride);
        });
        tree.write(fileName, content);
    }
    else {
        const fileName = (0, devkit_1.joinPathFragments)(root, '.eslintrc.json');
        (0, devkit_1.updateJson)(tree, fileName, (json) => {
            json.overrides = overrides;
            return json;
        });
    }
}
function addExtendsToLintConfig(tree, root, plugin) {
    const plugins = Array.isArray(plugin) ? plugin : [plugin];
    if ((0, flat_config_1.useFlatConfig)(tree)) {
        const fileName = (0, devkit_1.joinPathFragments)(root, (0, flat_config_1.flatConfigEslintFilename)(tree));
        const pluginExtends = (0, ast_utils_1.generatePluginExtendsElement)(plugins);
        let content = tree.read(fileName, 'utf8');
        content = (0, ast_utils_1.addCompatToFlatConfig)(content);
        tree.write(fileName, (0, ast_utils_1.addBlockToFlatConfigExport)(content, pluginExtends, {
            insertAtTheEnd: false,
        }));
    }
    else {
        const fileName = (0, devkit_1.joinPathFragments)(root, '.eslintrc.json');
        (0, devkit_1.updateJson)(tree, fileName, (json) => {
            json.extends ??= [];
            json.extends = [
                ...plugins,
                ...(Array.isArray(json.extends) ? json.extends : [json.extends]),
            ];
            return json;
        });
    }
}
function addPluginsToLintConfig(tree, root, plugin) {
    const plugins = Array.isArray(plugin) ? plugin : [plugin];
    if ((0, flat_config_1.useFlatConfig)(tree)) {
        const fileName = (0, devkit_1.joinPathFragments)(root, (0, flat_config_1.flatConfigEslintFilename)(tree));
        let content = tree.read(fileName, 'utf8');
        const mappedPlugins = [];
        plugins.forEach((name) => {
            const imp = getPluginImport(name);
            const varName = (0, devkit_1.names)(imp).propertyName;
            mappedPlugins.push({ name, varName, imp });
        });
        mappedPlugins.forEach(({ varName, imp }) => {
            content = (0, ast_utils_1.addImportToFlatConfig)(content, varName, imp);
        });
        content = (0, ast_utils_1.addPluginsToExportsBlock)(content, mappedPlugins);
        tree.write(fileName, content);
    }
    else {
        const fileName = (0, devkit_1.joinPathFragments)(root, '.eslintrc.json');
        (0, devkit_1.updateJson)(tree, fileName, (json) => {
            json.plugins = [...plugins, ...(json.plugins ?? [])];
            return json;
        });
    }
}
function addIgnoresToLintConfig(tree, root, ignorePatterns) {
    if ((0, flat_config_1.useFlatConfig)(tree)) {
        const fileName = (0, devkit_1.joinPathFragments)(root, (0, flat_config_1.flatConfigEslintFilename)(tree));
        const block = (0, ast_utils_1.generateAst)({
            ignores: ignorePatterns.map((path) => (0, path_utils_1.mapFilePath)(path)),
        });
        tree.write(fileName, (0, ast_utils_1.addBlockToFlatConfigExport)(tree.read(fileName, 'utf8'), block));
    }
    else {
        const fileName = (0, devkit_1.joinPathFragments)(root, '.eslintrc.json');
        (0, devkit_1.updateJson)(tree, fileName, (json) => {
            const ignoreSet = new Set([
                ...(json.ignorePatterns ?? []),
                ...ignorePatterns,
            ]);
            json.ignorePatterns = Array.from(ignoreSet);
            return json;
        });
    }
}
function getPluginImport(pluginName) {
    if (pluginName.includes('eslint-plugin-')) {
        return pluginName;
    }
    if (!pluginName.startsWith('@')) {
        return `eslint-plugin-${pluginName}`;
    }
    if (!pluginName.includes('/')) {
        return `${pluginName}/eslint-plugin`;
    }
    const [scope, name] = pluginName.split('/');
    return `${scope}/eslint-plugin-${name}`;
}
